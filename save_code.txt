
======================================== ./tuan1/b1(Text_Replacement).c ========================================

#include <stdio.h>
#include <string.h>
char p1[50] , p2[50] , t[10001] , ketqua[1001];
int main(){
    fgets(p1,50,stdin);
    p1[strcspn(p1,"\n")] = '\0';
    fgets(p2,50,stdin);
    p2[strcspn(p2,"\n")] = '\0';
    fgets(t,1001,stdin);
    t[strcspn(t,"\n")] = '\0';
    int i = 0 , post = 0;
    while(t[i]!='\0'){
        if(strncmp(&t[i],p1, strlen(p1))==0){
            strcpy(&ketqua[post],p2);
            post += strlen(p2);
            i+= strlen(p1);
        }
        else{
            ketqua[post] = t[i];
            i++;
            post++;
        }
    }
    for(int i =0 ; i <strlen(ketqua); i++) printf("%c",ketqua[i]);
    return 0;
    


}


======================================== ./tuan1/b2(Count_words).c ========================================

#include <stdio.h>

int main(){
    char ch;
    int i =0 , inword =0 ;
    while((ch=getchar())!= EOF){
        if(ch==' '||ch=='\n'||ch=='\t') inword = 0;
        else{
            if(inword == 0){
                i++;
                inword = 1;
            }
        }

    }
    printf("%d",i);
    return 0;
}


======================================== ./tuan1/b3(Find_all_divisor_of_an_integer ).c ========================================

#include <stdio.h>
#include <math.h>
int main(){
    long long n ;
    scanf("%lld", &n);
    int i , arr[10000];
    int dem = 0 ;
    for( i = 1 ; i <=sqrt(n); i++){
        if(n % i == 0){
            arr[dem] = i ;
            dem++;
            if(n/i != i){
                arr[dem] = n / i ;
                dem++;
            }
        }

    }
    for( i =0 ; i < dem ; i++){
        for(int j = i+1 ; j < dem ; j++ ){
            if(arr[i] < arr[j]){
                int temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            } 

        }
    }
    for(int i =0 ; i< dem ; i++) printf("%d ", -arr[i]);
   for(int i = dem -1 ; i >= 0 ; i--) printf("%d ", arr[i]);
    return 0;

    

}


======================================== ./tuan1/b4(Sum_Array).c ========================================

#include <stdio.h>
int main(){
    int n ; 
    scanf("%d", &n);
    int i, arr[n] ; 
    int sum = 0;
    for(i = 0 ; i < n ; i++){
        scanf("%d",&arr[i]);
        sum += arr[i];


    }
    printf("%d", sum);
    return 0;
}


======================================== ./tuan1/b5(Replace_characters_in_string).c ========================================

#include <stdio.h>
#include <string.h>

int main(void){
    char arr[20];
    char a, b;
    int i;
    if (scanf("%19s", arr) != 1) {
        return 1;
    }
    if (scanf(" %c %c", &a, &b) != 2) {
        return 1;
    }
    for (i = 0; i < (int)strlen(arr); i++) {
        if (arr[i] == a) {
            arr[i] = b;
        }
    }
    printf("%s\n", arr);
    return 0;
}



======================================== ./tuan2/b1(Black_Column).c ========================================

#include <stdio.h>
int ma[1001][1001];
int main(){
    int n , m;
    scanf("%d %d", &n , &m);
    int i,j;
    for( i= 0 ; i <n ; i++){
        for(j =0 ; j< m ; j++){
            scanf("%d", &ma[i][j]);
        }
    }
    int dem = 0 ;
    for( i =0 ; i <m ; i++){
        for(j =0 ; j < n ; j++){
            if(ma[j][i] != 1) break;
            if(j == n -1) dem++;

        }
    }
    printf("%d", dem);
    return 0;

}


======================================== ./tuan2/b2(Check_Queen_solution).c ========================================

#include <stdio.h>
int Qcheck(int arr[][101], int NxN){
    int  i , j ;
    for(i =0 ; i< NxN  ; i++){
        for(j = 0 ; j < NxN  ; j++){
            if(arr[i][j]== 1){
                int m ,n ;
                for(m = i+1 , n = j-1 ; m < NxN && n >= 0 ; m++ , n--) if(arr[m][n] == 1) return 0;
                for(m = i+1 , n = j+1 ; m < NxN && n < NxN ; m++ , n++) if(arr[m][n] == 1) return 0;
                for(m = i+1 , n = j ; m < NxN ; m++) if(arr[m][n] == 1) return 0;
                for(m = i , n = j+1 ; n < NxN ; n++) if(arr[m][n] == 1) return 0;


            }

            }
        }
        return 1 ;
}


int kq[100];
int arr[101][101] = {0};
int main(){
    int num;
    scanf("%d", &num);
    int i , j , k ;
    for( i =0 ; i < num ; i++){
        int NxN;
        scanf("%d", &NxN);
        for(j = 0 ; j < NxN ; j++){
            for(k =0 ; k< NxN ; k++){
                scanf("%d", &arr[j][k]);
            }
        }
        kq[i] = Qcheck(arr, NxN);
        
    }
    for( i =0 ; i < num ; i++) printf("%d\n", kq[i]);
    return 0;
}


======================================== ./tuan2/b3(Evaluate_expression_contains_operand).c ========================================

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define MOD 1000000007
char math[10001];
long long num[10001] ={0};
char op[5001] ;
int main(){
    fgets(math,10001,stdin);
    math[strcspn(math,"\n")]='\0';
    int length = strlen(math) ;
    if(math[0] == '+' || math[0] == '*' || math[length-1] =='+' || math[length-1] == '*'){
        printf("NOT_CORRECT");
        return 0;
    }
    int i;
    for( i= 0 ; i< length ; i++){
        if(math[i] == '*' || math[i] == '+'){
            if(math[i+1] == '*' || math[i+1] =='+'){
                printf("NOT_CORRECT");
                return 0;
            }
        }
    }
    char *ptr = math;
    int dem1 = 0 , dem2 = 0;
    while( *ptr != '\0'){
        num[dem1++] = strtoll(ptr,&ptr,10);
        if(*ptr != '\0'){
            op[dem2++] = *ptr;
            ptr++;
        }
    }
    for( i=0 ; i < dem2 ; i++){
        if(op[i] == '*'){
            num[i +1] = num[i] * num[i+1] % MOD;
            num[i] = 0 ;
        }
    }
    long long sum = 0 ; 
    for( i =0  ;i < dem1 ; i++){
        sum = (sum + num[i]) % MOD;
    }
    printf("%lld", sum % MOD);
    return 0;

}




======================================== ./tuan2/b4(Multiplication_of_2_matrices).c ========================================

#include <stdio.h>
int a[101][101] , b[101][101] , c[101][101] = {0};
int main(){
    int n , k ; 
    scanf("%d %d", &n , &k);
    int i , j ;
    for(i =0 ; i <n ; i++){
        for(j= 0 ; j< k ;j++){
            scanf("%d", &a[i][j]);
        }
    }
    int k1 , m;
    scanf("%d %d", &k1 , &m);
    for(i =0 ; i <k ; i++){
        for(j= 0 ; j< m ;j++){
            scanf("%d", &b[i][j]);
        }
    }
    for(i =0 ; i <n ; i++){
        for(j= 0 ; j< m ;j++){
            for(int h =0 ; h < k ; h++ ){
                c[i][j] += a[i][h]*b[h][j] ;


            }

        }
    }
    for(i =0 ; i <n ; i++){
        for(j= 0 ; j< m ;j++){
            printf("%d ", c[i][j]);
        }
        printf("\n");
    }

    return 0;

}


======================================== ./tuan2/b5(Bounding_rectangle).c ========================================

#include <stdio.h>
int arr[1001][4] ;
int main(){
    int n;
    scanf("%d", &n);
    int i ,j ;
    for( int i =0 ; i <n ;i++){
        for(j =0 ;j <4 ;j++){
            scanf("%d",&arr[i][j]);
        }
    }
    int x1 , y1 ,x2 ,y2 ;
    int temp1 =1001 , temp2 = 0 ;
    for(i =0 ; i < n ; i++){
        for(j =0 ; j <4 ; j+= 2){
            if(arr[i][j] < temp1) temp1 =arr[i][j];
            if(arr[i][j] > temp2) temp2 =arr[i][j];
        }
    }
    x1 = temp1 , x2 = temp2 ;
    temp1 =1001 , temp2 = 0 ;
    for(i =0 ; i < n ; i++){
        for(j =1 ; j <4 ; j+= 2){
            if(arr[i][j] < temp1) temp1 =arr[i][j];
            if(arr[i][j] > temp2) temp2 =arr[i][j];
        }
    }
    y1 = temp1 , y2 = temp2 ;
    int sum = (x2-x1)*(y2-y1);
    printf("%d", sum);
    return 0;


}


======================================== ./tuan2/b6(Report_student_doing_quiz_on_date).c ========================================

#include <stdio.h>
#include <string.h>
 typedef struct{
    int yyyy , mm , dd;
    int h , m , s;
    char user_id[10];
    int q_id;

 }sv;
int main(){
    sv  a[1000];
    int i =0 ;
    char line[100];
    while(1){
        fgets(line,100,stdin);
        line[strcspn(line,"\n")] = '\0';
        if( line[0] == '*') break;
        sscanf(line,"%d-%d-%d %d:%d:%d %s question%d ", &a[i].yyyy, &a[i].mm, &a[i].dd, &a[i].h, &a[i].m, &a[i].s, &a[i].user_id, &a[i].q_id);
        i++;
    }
    return 0;
    
}


======================================== ./tuan2/b7(Find_integer_solutions_to_Polynomial_Degree_3).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAX_ROOTS 3

long long cubic(int a, int b, int c, int x) {
    return (long long)x * x * x + (long long)a * x * x + (long long)b * x + c;
}

int find_divisors(int c, int divisors[]) {
    int count = 0;
    int abs_c = abs(c);
    for (int i = 1; i * i <= abs_c; ++i) {
        if (abs_c % i == 0) {
            divisors[count++] = i;
            if (i != abs_c / i)
                divisors[count++] = abs_c / i;
        }
    }
    if (c < 0) {
        int orig = count;
        for (int i = 0; i < orig; ++i)
            divisors[count++] = -divisors[i];
    }
    return count;
}

int main() {
    int a, b, c;
    if (scanf("%d %d %d", &a, &b, &c) != 3) {
        printf("NO SOLUTION\n");
        return 0;
    }
    int roots[MAX_ROOTS], mult[MAX_ROOTS], nroots = 0;
    int ca = a, cb = b, cc = c;
    int found = 0;
    int divisors[10000], dcount = 0;
    // Find all divisors of c (including negative)
    int abs_c = abs(c);
    for (int i = 1; i * (long long)i <= abs_c; ++i) {
        if (abs_c % i == 0) {
            divisors[dcount++] = i;
            if (i != abs_c / i) divisors[dcount++] = abs_c / i;
        }
    }
    for (int i = 0, orig = dcount; i < orig; ++i) divisors[dcount++] = -divisors[i];

    for (int k = 0; k < MAX_ROOTS; ++k) {
        int root = 0, multiplicity = 0;
        int found_root = 0;
        for (int i = 0; i < dcount; ++i) {
            int x = divisors[i];
            // Skip already used roots
            int skip = 0;
            for (int t = 0; t < nroots; ++t) if (roots[t] == x) skip = 1;
            if (skip) continue;
            long long val = (k == 0) ? ((long long)x * x * x + (long long)ca * x * x + (long long)cb * x + cc)
                            : (k == 1) ? ((long long)x * x + (long long)ca * x + cb)
                            : ((long long)x + ca);
            if (val == 0) {
                root = x;
                found_root = 1;
                break;
            }
        }
        if (!found_root) break;
        // Count multiplicity
        do {
            multiplicity++;
            if (k == 0) {
                int na = ca + root;
                int nb = cb + na * root;
                ca = na;
                cb = nb;
                cc = 0;
            } else if (k == 1) {
                int na = ca + root;
                ca = na;
                cb = 0;
            } else {
                ca = 0;
            }
            long long val = (k == 0) ? ((long long)root * root * root + (long long)ca * root * root + (long long)cb * root + cc)
                            : (k == 1) ? ((long long)root * root + (long long)ca * root + cb)
                            : ((long long)root + ca);
            if (val != 0) break;
        } while (multiplicity < 3);
        roots[nroots] = root;
        mult[nroots] = multiplicity;
        nroots++;
        found = 1;
    }
    int ok = 0;
    if (nroots == 3 && ca == 0 && cb == 0 && cc == 0) ok = 1;
    if (nroots == 2 && ca == 0 && cb == 0) ok = 1;
    if (nroots == 1 && ca == 0) ok = 1;
    if (!ok) {
        printf("NO SOLUTION\n");
        return 0;
    }
    for (int i = 0; i < nroots - 1; ++i)
        for (int j = i + 1; j < nroots; ++j)
            if (roots[i] > roots[j]) {
                int t = roots[i]; roots[i] = roots[j]; roots[j] = t;
                t = mult[i]; mult[i] = mult[j]; mult[j] = t;
            }
    for (int i = 0; i < nroots; ++i)
        printf("%d %d\n", roots[i], mult[i]);
    return 0;
}



======================================== ./tuan2/b8(Check_Sudoku).c ========================================

#include <stdio.h>

int check_row(int mat[9][9], int row) {
    int seen[10] = {0};
    for (int j = 0; j < 9; ++j) {
        int val = mat[row][j];
        if (val < 1 || val > 9 || seen[val]) return 0;
        seen[val] = 1;
    }
    return 1;
}

int check_col(int mat[9][9], int col) {
    int seen[10] = {0};
    for (int i = 0; i < 9; ++i) {
        int val = mat[i][col];
        if (val < 1 || val > 9 || seen[val]) return 0;
        seen[val] = 1;
    }
    return 1;
}

int check_square(int mat[9][9], int start_row, int start_col) {
    int seen[10] = {0};
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j) {
            int val = mat[start_row + i][start_col + j];
            if (val < 1 || val > 9 || seen[val]) return 0;
            seen[val] = 1;
        }
    return 1;
}

int is_sudoku(int mat[9][9]) {
    for (int i = 0; i < 9; ++i)
        if (!check_row(mat, i) || !check_col(mat, i))
            return 0;
    for (int i = 0; i < 9; i += 3)
        for (int j = 0; j < 9; j += 3)
            if (!check_square(mat, i, j))
                return 0;
    return 1;
}

int main() {
    int T;
    scanf("%d", &T);
    for (int t = 0; t < T; ++t) {
        int mat[9][9];
        for (int i = 0; i < 9; ++i)
            for (int j = 0; j < 9; ++j)
                scanf("%d", &mat[i][j]);
        printf("%d\n", is_sudoku(mat));
    }
    return 0;
}



======================================== ./tuan3/b1(Array_Equality).c ========================================

#include <stdio.h>
int arr1[1002] , arr2[1002] ;
int main(){
    int T ;
    scanf("%d", &T);
    int arr3[1001] = {0};
    int i , j;
    int dem = 0;
    for( i = 0 ;i < T ; i++){
        int n , m ;
        scanf("%d %d", &n , &m);
        for ( j =0 ; j < n ; j++) scanf("%d", &arr1[j]);
        for ( j =0 ; j < m ; j++) scanf("%d", &arr2[j]);
        if ( n != m){
            arr3[i] = 0 ;
            continue;
        }
        for(j =0 ; j <n ; j++){
            if(arr1[j] == arr2[j]) arr3[i] = 1;
            else{
                arr3[i] = 0;
                break;
            }

    }
    }
    for( i = 0 ; i < T ; i++) printf("%d\n", arr3[i]);
    return 0;

}


======================================== ./tuan3/b2(Basic_queries_on_array).c ========================================




======================================== ./tuan3/b3(Solve_degree_2_polynomial_equation).c ========================================

#include <stdio.h>
#include <math.h>
int main(){
    double a ,b , c;
    scanf("%lf %lf %lf", &a , &b , &c );
    double delta = b*b -4*a*c;
    if( a== 0){
        if( b== c | c== 0){
         printf("NO SOLUTION");
        return 0;   
        }
        printf("%.2lf", -c/b);
        return 0;
    }
    if( delta < 0){
        printf("NO SOLUTION");
        return 0;
    }
    if(delta == 0){
        printf("%.2lf", (-b)/(2*a));
        return 0;

    }
    else printf("%.2lf %.2lf", (-b-sqrt(delta))/(2*a) , (-b+sqrt(delta))/(2*a)  ) ;
    return 0;


}


======================================== ./tuan3/b4(k_Subsequence_even).c ========================================

#include <stdio.h>
int arr[100001];
int main(){
    int n , k;
    scanf("%d %d", &n , &k);
    int i , j ;
    for(i =0 ; i< n ; i++) scanf("%d", &arr[i]);
    int sum = 0 , dem = 0;
    for( i = 0 ; i <= n - k ; i++){
        for(j = 0 ; j < k ; j++){
            sum += arr[i+j];
        }
        if( sum % 2 == 0 ) dem++;
        sum = 0;

    }
    printf("%d", dem);
    return 0;

}


======================================== ./tuan3/b5(Find_all_perfect_square_in_a_sequence).c ========================================

#include <stdio.h>
#include <math.h>
int arr[1000001];
int main(){
    int n;
    scanf("%d", &n);
    int i,  dem =0 ;
    for( i =0 ; i< n ; i++){
        scanf("%d", &arr[i]);
        if( sqrt(arr[i]) == (int)sqrt(arr[i]) ) dem++;
    }
    printf("%d", dem);
    return 0;
}


======================================== ./tuan3/b6(Separate_the_integer_and_decimal_parts_of_a_float).c ========================================

#include <stdio.h>
int main(){
    double a;
    scanf("%lf", &a);
    int b = (int)a;
    if(b >a) b -= 1;
    double c = a - b ;
    printf("%d %.2f", b ,c);
    return 0;
}


======================================== ./tuan3/b7(Convert_a_TEXT_to_Upper-Case).c ========================================

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#define MAX 1000000
int main(){
    char arr[MAX];
     while (fgets(arr, MAX, stdin)){
    int i ;
    int k = 'A' - 'a';
    for( i=0 ; i < strlen(arr); i++){
        if('a' <= arr[i] && arr[i] <= 'z') arr[i] += k;
        
    }
    printf("%s", arr);
}
    return 0;
}


======================================== ./tuan3/b8(Basic_queries_on_array).c ========================================

#include <stdio.h>
#include <string.h>

int main() {
    int n;
    scanf("%d", &n);

    int a[10005];
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }

    char ch;
    while ((ch = getchar()) != '*' && ch != EOF);

    char cmd[50];
    while (1) {
        scanf("%s", cmd);
        if (strcmp(cmd, "***") == 0) break;

        if (strcmp(cmd, "find-max") == 0) {
            int max = a[0];
            for (int i = 1; i < n; i++)
                if (a[i] > max) max = a[i];
            printf("%d\n", max);
        } 
        
        else if (strcmp(cmd, "find-min") == 0) {
            int min = a[0];
            for (int i = 1; i < n; i++)
                if (a[i] < min) min = a[i];
            printf("%d\n", min);
        } 
        
        else if (strcmp(cmd, "sum") == 0) {
            int s = 0;
            for (int i = 0; i < n; i++)
                s += a[i];
            printf("%d\n", s);
        } 
        
        else if (strcmp(cmd, "find-max-segment") == 0) {
            int i, j;
            scanf("%d %d", &i, &j);
            i--; 
            j--; 
            int max = a[i];
            for (int k = i + 1; k <= j; k++)
                if (a[k] > max) max = a[k];
            printf("%d\n", max);
        }
    }

    return 0;
}



======================================== ./tuan3/bttuan3_202416969.c ========================================

#include <stdio.h>
#include <stdlib.h>

// Hàm Alloc_Cub(m, r, c)

int ***Alloc_Cub(int m, int r, int c) {
    int i, j;
    int ***a = (int ***)malloc(m * sizeof(int **));
    if (!a) return NULL;

    for (i = 0; i < m; i++) {
        a[i] = (int **)malloc(r * sizeof(int *));
        if (!a[i]) return NULL;
        for (j = 0; j < r; j++) {
            a[i][j] = (int *)calloc(c, sizeof(int));
            if (!a[i][j]) return NULL;
        }
    }
    return a;
}

//Hàm Free_Cub(...)
void Free_Cub(int ***a, int m, int r) {
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < r; j++)
            free(a[i][j]);
        free(a[i]);
    }
    free(a);
}

//* Hàm Realloc_Cub(...)

void Realloc_Cub(int ****p, int m, int r, int c, int m2, int r2, int c2) {
    int ***old = *p;
    int ***new = Alloc_Cub(m2, r2, c2);
    if (!new) return;
    int mm = (m < m2 ? m : m2);
    int rr = (r < r2 ? r : r2);
    int cc = (c < c2 ? c : c2);
    for (int i = 0; i < mm; i++)
        for (int j = 0; j < rr; j++)
            for (int k = 0; k < cc; k++)
                new[i][j][k] = old[i][j][k];

    Free_Cub(old, m, r);
    *p = new;
}

int main() {
    int m = 2, r = 3, c = 4;
    int ***a = Alloc_Cub(m, r, c);
    if (!a) return 1;

    // Gán giá trị mẫu
    for (int i = 0; i < m; i++)
        for (int j = 0; j < r; j++)
            for (int k = 0; k < c; k++)
                a[i][j][k] = i + j + k;

    printf(" Trước khi cấp phát lại \n");
    for (int i = 0; i < m; i++) {
        printf("M%d:\n", i);
        for (int j = 0; j < r; j++) {
            for (int k = 0; k < c; k++)
                printf("%3d ", a[i][j][k]);
            printf("\n");
        }
        printf("-----------------\n");
    }

    // Tái cấp phát mảng
    int m2 = 4, r2 = 4, c2 = 4;
    Realloc_Cub(&a, m, r, c, m2, r2, c2);

    printf("\n Sau khi cấp phát lại\n");
    for (int i = 0; i < m2; i++) {
        printf("M%d:\n", i);
        for (int j = 0; j < r2; j++) {
            for (int k = 0; k < c2; k++)
                printf("%3d ", a[i][j][k]);
            printf("\n");
        }
        printf("-----------------\n");
    }

    Free_Cub(a, m2, r2);
    return 0;
}



======================================== ./tuan4/b1(Compute_C_k_n).c ========================================

#include <stdio.h>
long long arr[1000][1000] = {0};
long long Ckn(int k , int n){
   if(k == 0 || k ==n) return 1;
   else if(k == 1) return n;
   if(arr[k][n] != 0) return arr[k][n] % 1000000007;
    arr[k][n] = (Ckn(k-1,n-1)+Ckn(k,n-1)) % 1000000007;
    return arr[k][n];
}
int main(){
    int k ,n ; 
    scanf("%d %d", &k , &n);
    printf("%lld", Ckn(k,n));
    return 0;
}


======================================== ./tuan4/b2(Subset_sum_of_elements_equal_to_B).c ========================================

#include <stdio.h>
int arr[101] = {0} ;
int a ,b ; 
int dem = 0;
int sum =0;
int Try(int k){
    for( int i =0 ; i<= 1 ; i++){
        if( i== 1) sum+= arr[k];
        if( sum > b){
            sum -= arr[k];
            continue;
        }
        if (k == a - 1) {
            if (sum == b) dem++;
            if (i == 1) sum -= arr[k]; 
        }

        else{
            Try(k+1);
            if( i == 1) sum -= arr[k];
        }


    }

}
int main(){
    scanf("%d %d", &a , &b);
    for( int i = 0 ; i < a ; i++) scanf("%d", &arr[i]);
    Try(0);
    printf("%d", dem);
    return 0;
}



======================================== ./tuan4/b3(Count_number_of_sudoku_solutions).c ========================================

#include <stdio.h>
int arr[10][10];
int dem =0 ;
int Check(int m , int n){
    for( int i =0 ; i < 9 ; i++){
        if(arr[m][n] == arr[i][n]&& arr[m][n] != 0&& i!= m)
        return 0;
    }
    for( int i =0 ; i < 9 ; i++){
        if(arr[m][n] == arr[m][i]&& arr[m][n] != 0 && i != n)
        return 0;
    }
    for(int i = m / 3 *3 ; i < m / 3 *3+3 ; i++){
        for(int j = n /3 *3 ; j < n /3 *3+3 ; j++){
            if(arr[m][n] == arr[i][j]&& arr[m][n] != 0 && (m!=i || n!= j))
            return 0;
        }
    }
    return 1;
}
void Try(int k1 , int k2){
    if(arr[k1][k2] == 0){
        for(int i = 1 ; i <= 9 ; i++){
            arr[k1][k2] = i ;
            if(Check(k1,k2)){
             if(k1 == 8 && k2 == 8 ) dem++;
             else if(k2 == 8) Try(k1+1, 0) ;
             else if(k2 < 8) Try(k1,k2+1) ;
            }
            arr[k1][k2] = 0 ;
        }
    }
    else if(arr[k1][k2] != 0){
        if(Check(k1,k2)){
        if(k1 == k2 && k1 == 8 ) dem++;
        else if(k2 == 8) Try(k1+1, 0) ;
        else if(k2 < 8) Try(k1,k2+1) ;
    }
    
}
}
int main(){
    for( int i =0 ; i< 9 ;i++){
        for(int j =0 ; j< 9; j++){
            scanf("%d", &arr[i][j]);
        }
    }
    Try(0,0);
    printf("%d", dem);
    return 0;
}



======================================== ./tuan4/b4(Permutation_generation).c ========================================

#include <stdio.h>
int n;
int arr[50]  = {0};
void solution(){
    int dem = 0;
    for(int i =0 ; i < n ;i++)
    printf("%d ", arr[i]);
    printf("\n");
    return;
}
int Check(){
    for(int i = 1 ; i < n ; i++ ){
        for(int j =0 ; j < i ; j++){
            if(arr[i] == arr[j]) return 0;
        }
    }
    return 1;
    
}
void Try(int k){
    for(int i =1 ; i<= n ; i++){
        arr[k] = i;  
        if(k == n -1){
            if (Check()){
             solution();
            }}
        else Try(k+1);
    }
}  

int main(){
    scanf("%d", &n);
    Try(0);
    return 0;
}


======================================== ./tuan4/b5(Convert_integer_to_binary_string).c ========================================

#include <stdio.h>
int n ;
void Binary( int n){
    if(n == 0 ){
        printf("0");
    }
    else if(n == 1 ){
        printf("1");
    }
    else{ Binary(n/2);
    printf("%d", n%2);}
    
}

int main(){
    scanf("%d", &n);
    Binary(n);
    return 0;
}


======================================== ./tuan4/b6(Binary_sequences_generation_without_consecutive_11).c ========================================

#include <stdio.h>
int n;
int arr[21] ={0};
void solution(){
    for( int i =0 ; i< n ;i++) printf("%d", arr[i]);
    printf("\n");
}
void Try(int k){
    for( int i =0 ; i <= 1 ; i++){
        arr[k] = i;
        if(arr[k] == 1 && arr[k-1] ==1 ) continue;
        if( k == n - 1) solution();
        else Try(k+1);
    }
}
int main(){
    scanf("%d", &n);
    Try(0);
    return 0;
}


======================================== ./tuan4/b7(Linear_Integer_Equation_coefficent_1).c ========================================

#include <stdio.h>
int n , m ;
int arr[11];
int sum = 0;
void solution(){
    for(int i=0 ;i <n ; i++)
    printf("%d ",arr[i]);
    printf("\n");
}
void Try( int k){
    for(int i = 1 ; i <= m -n + 1 ;i++){
        arr[k] = i;
        sum += i;
        if(k == n -1 ){
            if(sum == m) solution();
        }
        else if(sum >= m){
            sum -= i;
            continue;
        }
        else Try(k+1);
        sum -=i;

    }
}
int main(){
    scanf("%d %d", &n ,&m);
    Try(0);
    return 0;
}


======================================== ./tuan4/b8(Count_number_of_Queen_solutions_with_some_specified_queens).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
int arr[13][13] = {0};
int n;
int dem = 0;
int Check(int r, int c){
    for( int i =0 ; i < n ; i++){
        if(i!= c && arr[r][i] == 1) return 0;
    }
    for(int i =0 ; i < n ; i++ ){
        if(i!= r && arr[i][c] == 1) return 0;
    }
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            if(arr[i][j] == 1){
                if(i == r && j == c) continue;
                if(abs(i - r) == abs(j - c)) return 0;
            }
        }
    }

    return 1;
}

void TryRow(int r){
    if(r == n){
        dem++;
        return;
    }

    int preset_col = -1;
    for(int j = 0; j < n; ++j){
        if(arr[r][j] == 1){ preset_col = j; break; }
    }
    if(preset_col != -1){
        if(Check(r, preset_col)) TryRow(r+1);
        return;
    }
    for(int j = 0; j < n; ++j){
        if(Check(r, j)){
            arr[r][j] = 1;
            TryRow(r+1);
            arr[r][j] = 0;
        }
    }
}
int main(){
    scanf("%d", &n);
    for( int i =0 ; i <n ; i++){
        for(int j = 0 ; j < n ; j++ ){
            scanf("%d", &arr[i][j]);
        }
    }

    for(int i = 0; i < n; ++i){
        for(int j = 0; j < n; ++j){
            if(arr[i][j] == 1){
                if(!Check(i,j)){
                    printf("0");
                    return 0;
                }
            }
        }
    }

    TryRow(0);
    printf("%d", dem);
    return 0;

}



======================================== ./tuan5/b1(Hanoi_Tower).c ========================================

#include <stdio.h>
int n , A , B , C , D ;
int dem = 0;
int Hanoi(int n , int A, int B, int C, int D ){
    dem++;
    if(n==1){
        if(D!= 0 ) printf("%d %d\n", A, B);
        return dem;
    }
    Hanoi(n-1,A,C,B,D);
    if(D!=0) printf("%d %d\n", A,B);
    Hanoi(n-1,C,B,A,D);
}

int main(){
    scanf("%d %d %d %d", &n ,&A, &B, &C);
    Hanoi(n,A,B,C,0);
    printf("%d\n",dem);
    dem = 0;
    Hanoi(n,A,B,C,1);
    return 0;
}


======================================== ./tuan5/b2(Count_Solutions_TSP).c ========================================

#include <stdio.h>
#include <limits.h>
int n, maxdis;
int arr[101][101];
int dis = 0 ;
int dem = 0;
int C[101]; //tp di qua 
int visited[101] = {0};
void Try( int i){
    for( int j =1 ; j < n ; j++){
        if( visited[j] == 0){
            visited[j] = 1;
            C[i] =j ;
            dis += arr[C[i-1]][C[i]];
            if( i < n - 1 ) Try(i+1);
            else if(i == n -1){
                if(maxdis - dis - arr[C[n-1]][C[0]] >= 0) dem++;
            }
        }
        else continue;
        visited[j] = 0 ; 
        dis -= arr[C[i-1]][C[i]];


    }
}
int main(){
    scanf("%d %d", &n, &maxdis);
    for( int i =0 ; i < n ; i++ ){
        for( int j =0 ; j < n ;j++){
            scanf("%d", &arr[i][j]);
        }
    }
    visited[0] = 1;
    Try(1);
    printf("%d", dem);
 return 0;
}


======================================== ./tuan5/b3(Binary_sequence_generation).c ========================================

#include <stdio.h>
int n ; 
int arr[21];
void solution(){
    for( int i = 0 ; i < n ; i++){
        printf("%d", arr[i]);
    }
    printf("\n");
}
void Try( int k){
    for( int i =0 ; i <=1 ; i++){
        arr[k] = i ;
        if (k < n -1 ) Try( k +1);
        else if( k == n -1 ) solution();

    }
}
int main(){
    scanf("%d", &n);
    Try(0);
    return 0;
}


======================================== ./tuan5/b4(Fibonacci).c ========================================

#include <stdio.h>
int n, arr[100002]= {0};
long long Fun(int n){
    if(n < 0) return 0;
    if(n==0) return 0;
    else if(n==1) return 1;
    else if(n>=2){
       if (arr[n] !=0) return arr[n];
        else{
        arr[n]=(Fun(n-1)+Fun(n-2))%1000000007;
            return arr[n];
        }
    }
    return 0;
}
int main()
{
    scanf("%d",&n);
    printf("%lld",Fun(n));
    return 0;

}



======================================== ./tuan5/b5(Greatest_Common_Divisor).c ========================================

#include <stdio.h>
int GCD( int a , int b){
    if(a%b == 0) return b;
    a = a % b ;
    return GCD(b,a);
}
int main(){
    int a , b; 
    scanf("%d %d", &a , &b);
    printf("%d", GCD(a,b));
    return 0;
}


======================================== ./tuan5/b6(TSP).c ========================================

#include <stdio.h>
#include <limits.h>
int mindis = INT_MAX;
int n, dis = 0 ;
int arrdis[105][105];
int last[105];
int visited[105] = {0};
void Try( int i){
    for( int j = 1 ; j < n ; j++){
        if(visited[j] == 0 ){
            visited[j] = 1 ;
            last[i] = j ;
            dis += arrdis[last[i-1]][last[i]];
            if( dis > mindis){
                visited[j] = 0;
                dis -= arrdis[last[i -1 ]][last[i]];
                continue;
            }
            if( i < n -1 ) Try(i+1);
            else if(i == n-1){
                if( mindis > dis + arrdis[last[n-1]][last[0]])
                mindis = dis + arrdis[last[n-1]][last[0]];
            }
        }
        else continue;
        visited[j] = 0;
        dis -= arrdis[last[i -1 ]][last[i]];
    }

}
int main(){
    scanf("%d", &n);
    for( int i = 0 ; i <n ; i++){
        for( int j =0 ; j< n ; j++){
            scanf("%d", &arrdis[i][j]);
        }
    }
    visited[0] = 1 ;
    Try(1);
    printf("%d", mindis);
    return 0;
}


======================================== ./tuan6/b1(WATER_JUGS).c ========================================




======================================== ./tuan6/b2(Simulation_Stack).c ========================================




======================================== ./tuan6/b3(Simulation_Queue).c ========================================




======================================== ./tuan6/b4(Polynomial_Manipulation).c ========================================




======================================== ./tuan6/b5(Parenthesis).c ========================================




======================================== ./tuan6/b6(Maze).c ========================================




======================================== ./tuan6/b7(Linked_List_Manipulation).c ========================================

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct Node{
    int key;
    struct Node* next;
}node;

node* head = NULL;
// ktra num co trong list chua
int Check( int num){
    node* p = head;
    while(p != NULL){
        if(p->key == num) return(1);
        p = p -> next;
    }
    return 0;
}
// them vao cuoi danh sach
void addlast( int num){
    if(Check(num)) return;
    node* newnode = (node*)malloc(sizeof(node));
    newnode -> key = num;
    newnode -> next = NULL;
    if(!head){
        head = newnode;
        return;
    }
    node* p = head;
    while(p -> next) p = p-> next;
    p-> next = newnode;
}
//thêm vào đầu danh sách 
void addfirst( int num){
    if(Check(num)) return; 
    node* newnode = (node*)malloc(sizeof(node));
    newnode -> key = num;
    newnode -> next = head;
    head = newnode;
}
//thêm u  sau v
void addafter( int u , int v){
    if(Check(u)) return;
    node* p = head;
    while(p &&  p-> key != v)p = p -> next;
    if( !p ) return;
    node* newnode = (node*)malloc(sizeof(node));
    newnode -> key = u;
    newnode -> next = p -> next;
    p-> next = newnode ;
}









======================================== ./tuan6/b8(Delete_number).c ========================================




======================================== ./tuan7/b1(Binary_Tree_Manipulation_&_Traversal).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int id;
    struct Node *left, *right;
} Node;

Node* root = NULL;
Node* find(Node* r, int id) {
    if (r == NULL) return NULL;
    if (r->id == id) return r;
    Node* left = find(r->left, id);
    if (left) return left;
    return find(r->right, id);
}
Node* newNode(int id) {
    Node* p = (Node*)malloc(sizeof(Node));
    p->id = id;
    p->left = p->right = NULL;
    return p;
}
void preOrder(Node* r) {
    if (r == NULL) return;
    printf("%d ", r->id);
    preOrder(r->left);
    preOrder(r->right);
}
void inOrder(Node* r) {
    if (r == NULL) return;
    inOrder(r->left);
    printf("%d ", r->id);
    inOrder(r->right);
}
void postOrder(Node* r) {
    if (r == NULL) return;
    postOrder(r->left);
    postOrder(r->right);
    printf("%d ", r->id);
}

int main() {
    char cmd[20];
    int u, v;

    while (1) {
        scanf("%s", cmd);
        if (cmd[0] == '*') break;

        if (strcmp(cmd, "MakeRoot") == 0) {
            scanf("%d", &u);
            root = newNode(u);
        }
        else if (strcmp(cmd, "AddLeft") == 0) {
            scanf("%d %d", &u, &v);
            if (find(root, u) != NULL) continue;    
            Node* parent = find(root, v);
            if (parent == NULL) continue;            
            if (parent->left != NULL) continue;  
            parent->left = newNode(u);
        }
        else if (strcmp(cmd, "AddRight") == 0) {
            scanf("%d %d", &u, &v);
            if (find(root, u) != NULL) continue;
            Node* parent = find(root, v);
            if (parent == NULL) continue;
            if (parent->right != NULL) continue;
            parent->right = newNode(u);
        }
        else if (strcmp(cmd, "PreOrder") == 0) {
            preOrder(root);
            printf("\n");
        }
        else if (strcmp(cmd, "InOrder") == 0) {
            inOrder(root);
            printf("\n");
        }
        else if (strcmp(cmd, "PostOrder") == 0) {
            postOrder(root);
            printf("\n");
        }
    }

    return 0;
}



======================================== ./tuan7/b2(Binary_tree_path_sum).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

typedef struct Node {
    int id;
    struct Node *left, *right;
} Node;

#define MAXN 10005
Node* nodes[MAXN];

Node* createNode(int id) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->id = id;
    node->left = node->right = NULL;
    return node;
}

bool hasPathSum(Node* root, int targetSum, int currentSum) {
    if (!root) return false;
    currentSum += root->id;

    if (!root->left && !root->right) {
        return currentSum == targetSum;
    }

    return hasPathSum(root->left, targetSum, currentSum) ||
           hasPathSum(root->right, targetSum, currentSum);
}

int main() {
    char cmd[20];
    int u, v;
    Node* root = NULL;

    for (int i = 0; i < MAXN; i++) nodes[i] = NULL;

    while (scanf("%s", cmd)) {
        if (strcmp(cmd, "*") == 0) break;

        if (strcmp(cmd, "MakeRoot") == 0) {
            scanf("%d", &u);
            if (!nodes[u]) {
                nodes[u] = createNode(u);
            }
            root = nodes[u];
        }
        else if (strcmp(cmd, "AddLeft") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v] && nodes[v]->left == NULL) {
                nodes[u] = createNode(u);
                nodes[v]->left = nodes[u];
            }
        }
        else if (strcmp(cmd, "AddRight") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v] && nodes[v]->right == NULL) {
                nodes[u] = createNode(u);
                nodes[v]->right = nodes[u];
            }
        }
        else if (strcmp(cmd, "PathSum") == 0) {
            scanf("%d", &u);
            if (root && hasPathSum(root, u, 0)) {
                printf("True\n");
            } else {
                printf("False\n");
            }
        }
    }

    return 0;
}



======================================== ./tuan7/b3(Family_Tree).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
typedef struct Node {
    char name[50];
    struct Node* children[100]; 
    int childCount;
} Node;

#define MAXN 10005
Node* nodes[MAXN];
int nodeCount = 0;
Node* getNode(char* name) {
    for (int i = 0; i < nodeCount; i++) {
        if (strcmp(nodes[i]->name, name) == 0) return nodes[i];
    }
    Node* newNode = (Node*)malloc(sizeof(Node));
    strcpy(newNode->name, name);
    newNode->childCount = 0;
    nodes[nodeCount++] = newNode;
    return newNode;
}
int countDescendants(Node* root) {
    if (!root) return 0;
    int total = root->childCount;
    for (int i = 0; i < root->childCount; i++) {
        total += countDescendants(root->children[i]);
    }
    return total;
}
int countGenerations(Node* root) {
    if (!root || root->childCount == 0) return 0;
    int maxGen = 0;
    for (int i = 0; i < root->childCount; i++) {
        int g = countGenerations(root->children[i]);
        if (g > maxGen) maxGen = g;
    }
    return 1 + maxGen;
}

int main() {
    char child[50], parent[50];
    char cmd[20], param[50];
    while (scanf("%s", child)) {
        if (strcmp(child, "***") == 0) break;
        scanf("%s", parent);
        Node* cNode = getNode(child);
        Node* pNode = getNode(parent);
        pNode->children[pNode->childCount++] = cNode;
    }
    while (scanf("%s", cmd)) {
        if (strcmp(cmd, "***") == 0) break;
        scanf("%s", param);
        Node* node = getNode(param);

        if (strcmp(cmd, "descendants") == 0) {
            printf("%d\n", countDescendants(node));
        } else if (strcmp(cmd, "generation") == 0) {
            printf("%d\n", countGenerations(node));
        }
    }

    return 0;
}



======================================== ./tuan7/b4(Check_balanced_binary_tree_and_compute_the_height).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

typedef struct Node {
    int id;
    struct Node *left, *right;
} Node;

#define MAXN 50005
Node* nodes[MAXN];   
Node* root = NULL;

Node* getNode(int id) {
    if (nodes[id] == NULL) {
        nodes[id] = (Node*)malloc(sizeof(Node));
        nodes[id]->id = id;
        nodes[id]->left = nodes[id]->right = NULL;
    }
    return nodes[id];
}

int checkHeight(Node* node, bool* balanced) {
    if (!node) return 0;
    int lh = checkHeight(node->left, balanced);
    int rh = checkHeight(node->right, balanced);
    if (abs(lh - rh) > 1) *balanced = false;
    return (lh > rh ? lh : rh) + 1;
}

int main() {
    char cmd[20];
    int u, v;
    for (int i = 0; i < MAXN; i++) nodes[i] = NULL;

    while (scanf("%s", cmd)) {
        if (strcmp(cmd, "*") == 0) break;

        if (strcmp(cmd, "MakeRoot") == 0) {
            scanf("%d", &u);
            root = getNode(u);
        }
        else if (strcmp(cmd, "AddLeft") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v] && nodes[v]->left == NULL) {
                nodes[u] = getNode(u);
                nodes[v]->left = nodes[u];
            }
        }
        else if (strcmp(cmd, "AddRight") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v] && nodes[v]->right == NULL) {
                nodes[u] = getNode(u);
                nodes[v]->right = nodes[u];
            }
        }
    }

    bool balanced = true;
    int height = checkHeight(root, &balanced);

    printf("%d %d\n", balanced ? 1 : 0, height);

    return 0;
}



======================================== ./tuan7/b5(Tree_manipulation_&_Traversal).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int id;
    struct Node* children[100];
    int childCount;
} Node;

#define MAXN 10005
Node* nodes[MAXN];
Node* root = NULL;
Node* getNode(int id) {
    if (nodes[id] == NULL) {
        nodes[id] = (Node*)malloc(sizeof(Node));
        nodes[id]->id = id;
        nodes[id]->childCount = 0;
    }
    return nodes[id];
}

// Duyệt PreOrder
void preorder(Node* node) {
    if (!node) return;
    printf("%d ", node->id);
    for (int i = 0; i < node->childCount; i++) {
        preorder(node->children[i]);
    }
}

void inorder(Node* node) {
    if (!node) return;
    int mid = node->childCount / 2;
    for (int i = 0; i < mid; i++) {
        inorder(node->children[i]);
    }
    printf("%d ", node->id);
    for (int i = mid; i < node->childCount; i++) {
        inorder(node->children[i]);
    }
}

void postorder(Node* node) {
    if (!node) return;
    for (int i = 0; i < node->childCount; i++) {
        postorder(node->children[i]);
    }
    printf("%d ", node->id);
}

int main() {
    char cmd[20];
    int u, v;

    for (int i = 0; i < MAXN; i++) nodes[i] = NULL;

    while (scanf("%s", cmd)) {
        if (strcmp(cmd, "*") == 0) break;

        if (strcmp(cmd, "MakeRoot") == 0) {
            scanf("%d", &u);
            root = getNode(u);
        }
        else if (strcmp(cmd, "Insert") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v]) {
                Node* child = getNode(u);
                Node* parent = nodes[v];
                parent->children[parent->childCount++] = child;
            }
        }
        else if (strcmp(cmd, "PreOrder") == 0) {
            preorder(root);
            printf("\n");
        }
        else if (strcmp(cmd, "InOrder") == 0) {
            inorder(root);
            printf("\n");
        }
        else if (strcmp(cmd, "PostOrder") == 0) {
            postorder(root);
            printf("\n");
        }
    }

    return 0;
}



======================================== ./tuan7/b6(Tree_manipulation_and_traversal).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int id;
    struct Node* children[100]; // danh sách con
    int childCount;
} Node;

#define MAXN 50005
Node* nodes[MAXN];
Node* root = NULL;

// Tạo hoặc lấy node theo id
Node* getNode(int id) {
    if (nodes[id] == NULL) {
        nodes[id] = (Node*)malloc(sizeof(Node));
        nodes[id]->id = id;
        nodes[id]->childCount = 0;
    }
    return nodes[id];
}

// Duyệt PreOrder: thăm node trước, rồi duyệt các con
void preorder(Node* node) {
    if (!node) return;
    printf("%d ", node->id);
    for (int i = 0; i < node->childCount; i++) {
        preorder(node->children[i]);
    }
}

// Duyệt InOrder: nếu có 1 con → duyệt con rồi node; nếu nhiều con → nửa đầu, node, nửa sau
void inorder(Node* node) {
    if (!node) return;

    if (node->childCount == 1) {
        inorder(node->children[0]);
        printf("%d ", node->id);
    } else {
        int mid = node->childCount / 2;
        for (int i = 0; i < mid; i++) {
            inorder(node->children[i]);
        }
        printf("%d ", node->id);
        for (int i = mid; i < node->childCount; i++) {
            inorder(node->children[i]);
        }
    }
}

// Duyệt PostOrder: duyệt các con trước, rồi thăm node
void postorder(Node* node) {
    if (!node) return;
    for (int i = 0; i < node->childCount; i++) {
        postorder(node->children[i]);
    }
    printf("%d ", node->id);
}

int main() {
    char cmd[20];
    int u, v;

    for (int i = 0; i < MAXN; i++) nodes[i] = NULL;

    while (scanf("%s", cmd)) {
        if (strcmp(cmd, "*") == 0) break;

        if (strcmp(cmd, "MakeRoot") == 0) {
            scanf("%d", &u);
            root = getNode(u);
        }
        else if (strcmp(cmd, "Insert") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v]) {
                Node* child = getNode(u);
                Node* parent = nodes[v];
                parent->children[parent->childCount++] = child;
            }
        }
        else if (strcmp(cmd, "PreOrder") == 0) {
            preorder(root);
            printf("\n");
        }
        else if (strcmp(cmd, "InOrder") == 0) {
            inorder(root);
            printf("\n");
        }
        else if (strcmp(cmd, "PostOrder") == 0) {
            postorder(root);
            printf("\n");
        }
    }

    return 0;
}



======================================== ./tuan7/b7(Tree_manipulation_query_depth_-_height).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int id;
    struct Node* children[100];
    int childCount;
    struct Node* parent;
} Node;

#define MAXN 50005
Node* nodes[MAXN];
Node* root = NULL;

// Tạo hoặc lấy node theo id
Node* getNode(int id) {
    if (nodes[id] == NULL) {
        nodes[id] = (Node*)malloc(sizeof(Node));
        nodes[id]->id = id;
        nodes[id]->childCount = 0;
        nodes[id]->parent = NULL;
    }
    return nodes[id];
}

// Tính độ cao của nút (số tầng từ nút đến lá sâu nhất)
int getHeight(Node* node) {
    if (!node) return 0;
    int maxH = 0;
    for (int i = 0; i < node->childCount; i++) {
        int h = getHeight(node->children[i]);
        if (h > maxH) maxH = h;
    }
    return maxH + 1; // bao gồm chính nó
}

// Tính độ sâu của nút (số tầng từ gốc đến nút)
int getDepth(Node* node) {
    int depth = 1; // gốc có độ sâu là 1
    while (node && node->parent) {
        node = node->parent;
        depth++;
    }
    return depth;
}

int main() {
    char cmd[20];
    int u, v;

    for (int i = 0; i < MAXN; i++) nodes[i] = NULL;

    while (scanf("%s", cmd)) {
        if (strcmp(cmd, "*") == 0) break;

        if (strcmp(cmd, "MakeRoot") == 0) {
            scanf("%d", &u);
            root = getNode(u);
        }
        else if (strcmp(cmd, "Insert") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v]) {
                Node* child = getNode(u);
                Node* parent = nodes[v];
                parent->children[parent->childCount++] = child;
                child->parent = parent;
            }
        }
        else if (strcmp(cmd, "Height") == 0) {
            scanf("%d", &u);
            printf("%d\n", getHeight(nodes[u]));
        }
        else if (strcmp(cmd, "Depth") == 0) {
            scanf("%d", &u);
            printf("%d\n", getDepth(nodes[u]));
        }
    }

    return 0;
}



======================================== ./tuan8/b1(Classification_of_students_based_on_grades).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char id[11];
    int grade;
    int position;
} Student;

int compareGrade(const void* a, const void* b) {
    return ((Student*)a)->grade - ((Student*)b)->grade;
}

int compareID(const void* a, const void* b) {
    return strcmp(((Student*)a)->id, ((Student*)b)->id);
}

int main() {
    int n;
    scanf("%d", &n);

    Student* students = (Student*)malloc(n * sizeof(Student));

    for (int i = 0; i < n; i++) {
        scanf("%s %d", students[i].id, &students[i].grade);
    }

    // Sắp xếp theo điểm để gán vị trí
    qsort(students, n, sizeof(Student), compareGrade);
    for (int i = 0; i < n; i++) {
        students[i].position = i;
    }

    // Sắp xếp lại theo ID để in ra đúng thứ tự
    qsort(students, n, sizeof(Student), compareID);
    for (int i = 0; i < n; i++) {
        printf("%s %d\n", students[i].id, students[i].position);
    }

    free(students);
    return 0;
}



======================================== ./tuan8/b2(Max_Cardinality_Common_Subset_of_2_Sets).c ========================================

#include <stdio.h>
#include <stdlib.h>

int cmp(const void* a, const void* b) {
    int x = *(int*)a;
    int y = *(int*)b;
    if (x < y) return -1;
    if (x > y) return 1;
    return 0;
}

int main() {
    int n, m;
    scanf("%d %d", &n, &m);

    int *A = (int*)malloc(n * sizeof(int));
    int *B = (int*)malloc(m * sizeof(int));

    for (int i = 0; i < n; i++) scanf("%d", &A[i]);
    for (int j = 0; j < m; j++) scanf("%d", &B[j]);
    qsort(B, m, sizeof(int), cmp);

    int count = 0;
    for (int i = 0; i < n; i++) {
        if (bsearch(&A[i], B, m, sizeof(int), cmp) != NULL) {
            count++;
        }
    }

    printf("%d\n", count);

    free(A);
    free(B);
    return 0;
}



======================================== ./tuan8/b3(Pair_sum).c ========================================

#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a, const void *b) {
    return (*(int*)a - *(int*)b);
}

long long count_pairs(int *a, int n, long long x) {
    int l = 0, r = n - 1;
    long long ans = 0;

    while (l < r) {
        if ((long long)a[l] + a[r] <= x) {
            ans += (r - l);  // tất cả cặp (l, l+1..r)
            l++;
        } else {
            r--;
        }
    }

    return ans;
}

int main() {
    int n;
    scanf("%d", &n);

    int *a = (int*)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);

    qsort(a, n, sizeof(int), cmp);

    int q;
    scanf("%d", &q);

    while (q--) {
        long long x;
        scanf("%lld", &x);
        printf("%lld\n", count_pairs(a, n, x));
    }

    free(a);
    return 0;
}



======================================== ./tuan8/b4(Sort_a_sequence_of_integers).c ========================================

#include <stdio.h>

#define MAXA 100000

int cnt[MAXA + 1];

int main() {
    int n, x;
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        scanf("%d", &x);
        cnt[x]++;
    }

    int printed = 0;
    for (int v = 0; v <= MAXA; v++) {
        while (cnt[v] > 0) {
            printf("%d", v);
            printed++;
            if (printed < n) printf(" ");
            cnt[v]--;
        }
    }
    return 0;
}



======================================== ./tuan8/b5(Sort_candidates_of_a_Contest).c ========================================

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    char code[15];
    int score;
} Candidate;

int cmp(const void *a, const void *b) {
    Candidate *x = (Candidate *)a;
    Candidate *y = (Candidate *)b;
    return y->score - x->score;   // giảm dần
}

int main() {
    Candidate a[1000005];
    int n = 0;

    char code[15];
    int score;

    while (1) {
        if (scanf("%s", code) != 1) return 0;

        if (strcmp(code, "#") == 0) break;
        
        scanf("%d", &score);

        strcpy(a[n].code, code);
        a[n].score = score;
        n++;
    }

    qsort(a, n, sizeof(Candidate), cmp);

    for (int i = 0; i < n; i++) {
        printf("%s %d\n", a[i].code, a[i].score);
    }

    return 0;
}



======================================== ./tuan8/b6(Sort_Strings).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Comparator function for qsort
int cmp(const void *a, const void *b) {
    return strcmp(*(const char **)a, *(const char **)b);
}

int main() {
    int n;
    scanf("%d", &n);

    // Allocate array of string pointers
    char **arr = (char **)malloc(n * sizeof(char *));
    for (int i = 0; i < n; i++) {
        arr[i] = (char *)malloc(105 * sizeof(char)); // assuming max length ~100
        scanf("%s", arr[i]);
    }

    // Sort using qsort
    qsort(arr, n, sizeof(char *), cmp);

    // Print sorted strings
    for (int i = 0; i < n; i++) {
        printf("%s\n", arr[i]);
        free(arr[i]); // free each string
    }
    free(arr); // free array of pointers

    return 0;
}



======================================== ./tuan8/b7(Sort_vectors_in_a_lexicographic_order).c ========================================

#include <stdio.h>
#include <stdlib.h>

int n, m;
int a[100000][10];

int cmp(const void *x, const void *y) {
    const int *v1 = (const int *)x;
    const int *v2 = (const int *)y;

    for (int i = 0; i < m; i++) {
        if (v1[i] < v2[i]) return -1;
        if (v1[i] > v2[i]) return 1;
    }
    return 0;
}

int main() {
    scanf("%d %d", &n, &m);

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            scanf("%d", &a[i][j]);

    qsort(a, n, sizeof(a[0]), cmp);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            printf("%d ", a[i][j]);
        printf("\n");
    }

    return 0;
}


