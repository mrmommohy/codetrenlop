
======================================== ./tuan1/b1(Text_Replacement).c ========================================

#include <stdio.h>
#include <string.h>
char p1[50] , p2[50] , t[10001] , ketqua[1001];
int main(){
    fgets(p1,50,stdin);
    p1[strcspn(p1,"\n")] = '\0';
    fgets(p2,50,stdin);
    p2[strcspn(p2,"\n")] = '\0';
    fgets(t,1001,stdin);
    t[strcspn(t,"\n")] = '\0';
    int i = 0 , post = 0;
    while(t[i]!='\0'){
        if(strncmp(&t[i],p1, strlen(p1))==0){
            strcpy(&ketqua[post],p2);
            post += strlen(p2);
            i+= strlen(p1);
        }
        else{
            ketqua[post] = t[i];
            i++;
            post++;
        }
    }
    for(int i =0 ; i <strlen(ketqua); i++) printf("%c",ketqua[i]);
    return 0;
    


}


======================================== ./tuan1/b2(Count_words).c ========================================

#include <stdio.h>

int main(){
    char ch;
    int i =0 , inword =0 ;
    while((ch=getchar())!= EOF){
        if(ch==' '||ch=='\n'||ch=='\t') inword = 0;
        else{
            if(inword == 0){
                i++;
                inword = 1;
            }
        }

    }
    printf("%d",i);
    return 0;
}


======================================== ./tuan1/b3(Find_all_divisor_of_an_integer ).c ========================================

#include <stdio.h>
#include <math.h>
int main(){
    long long n ;
    scanf("%lld", &n);
    int i , arr[10000];
    int dem = 0 ;
    for( i = 1 ; i <=sqrt(n); i++){
        if(n % i == 0){
            arr[dem] = i ;
            dem++;
            if(n/i != i){
                arr[dem] = n / i ;
                dem++;
            }
        }

    }
    for( i =0 ; i < dem ; i++){
        for(int j = i+1 ; j < dem ; j++ ){
            if(arr[i] < arr[j]){
                int temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            } 

        }
    }
    for(int i =0 ; i< dem ; i++) printf("%d ", -arr[i]);
   for(int i = dem -1 ; i >= 0 ; i--) printf("%d ", arr[i]);
    return 0;

    

}


======================================== ./tuan1/b4(Sum_Array).c ========================================

#include <stdio.h>
int main(){
    int n ; 
    scanf("%d", &n);
    int i, arr[n] ; 
    int sum = 0;
    for(i = 0 ; i < n ; i++){
        scanf("%d",&arr[i]);
        sum += arr[i];


    }
    printf("%d", sum);
    return 0;
}


======================================== ./tuan1/b5(Replace_characters_in_string).c ========================================

#include <stdio.h>
#include <string.h>

int main(void){
    char arr[20];
    char a, b;
    int i;
    if (scanf("%19s", arr) != 1) {
        return 1;
    }
    if (scanf(" %c %c", &a, &b) != 2) {
        return 1;
    }
    for (i = 0; i < (int)strlen(arr); i++) {
        if (arr[i] == a) {
            arr[i] = b;
        }
    }
    printf("%s\n", arr);
    return 0;
}



======================================== ./tuan1/rac.c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAX_ROOTS 3

long long cubic(int a, int b, int c, int x) {
    return (long long)x * x * x + (long long)a * x * x + (long long)b * x + c;
}

int find_divisors(int c, int divisors[]) {
    int count = 0;
    int abs_c = abs(c);
    for (int i = 1; i * i <= abs_c; ++i) {
        if (abs_c % i == 0) {
            divisors[count++] = i;
            if (i != abs_c / i)
                divisors[count++] = abs_c / i;
        }
    }
    if (c < 0) {
        int orig = count;
        for (int i = 0; i < orig; ++i)
            divisors[count++] = -divisors[i];
    }
    return count;
}

int main() {
    int a, b, c;
    if (scanf("%d %d %d", &a, &b, &c) != 3) {
        printf("NO SOLUTION\n");
        return 0;
    }
    int roots[MAX_ROOTS], mult[MAX_ROOTS], nroots = 0;
    int ca = a, cb = b, cc = c;
    int found = 0;
    int divisors[10000], dcount = 0;
    // Find all divisors of c (including negative)
    int abs_c = abs(c);
    for (int i = 1; i * (long long)i <= abs_c; ++i) {
        if (abs_c % i == 0) {
            divisors[dcount++] = i;
            if (i != abs_c / i) divisors[dcount++] = abs_c / i;
        }
    }
    for (int i = 0, orig = dcount; i < orig; ++i) divisors[dcount++] = -divisors[i];

    for (int k = 0; k < MAX_ROOTS; ++k) {
        int root = 0, multiplicity = 0;
        int found_root = 0;
        for (int i = 0; i < dcount; ++i) {
            int x = divisors[i];
            // Skip already used roots
            int skip = 0;
            for (int t = 0; t < nroots; ++t) if (roots[t] == x) skip = 1;
            if (skip) continue;
            long long val = (k == 0) ? ((long long)x * x * x + (long long)ca * x * x + (long long)cb * x + cc)
                            : (k == 1) ? ((long long)x * x + (long long)ca * x + cb)
                            : ((long long)x + ca);
            if (val == 0) {
                root = x;
                found_root = 1;
                break;
            }
        }
        if (!found_root) break;
        // Count multiplicity
        do {
            multiplicity++;
            if (k == 0) {
                int na = ca + root;
                int nb = cb + na * root;
                ca = na;
                cb = nb;
                cc = 0;
            } else if (k == 1) {
                int na = ca + root;
                ca = na;
                cb = 0;
            } else {
                ca = 0;
            }
            long long val = (k == 0) ? ((long long)root * root * root + (long long)ca * root * root + (long long)cb * root + cc)
                            : (k == 1) ? ((long long)root * root + (long long)ca * root + cb)
                            : ((long long)root + ca);
            if (val != 0) break;
        } while (multiplicity < 3);
        roots[nroots] = root;
        mult[nroots] = multiplicity;
        nroots++;
        found = 1;
    }
    int ok = 0;
    if (nroots == 3 && ca == 0 && cb == 0 && cc == 0) ok = 1;
    if (nroots == 2 && ca == 0 && cb == 0) ok = 1;
    if (nroots == 1 && ca == 0) ok = 1;
    if (!ok) {
        printf("NO SOLUTION\n");
        return 0;
    }
    for (int i = 0; i < nroots - 1; ++i)
        for (int j = i + 1; j < nroots; ++j)
            if (roots[i] > roots[j]) {
                int t = roots[i]; roots[i] = roots[j]; roots[j] = t;
                t = mult[i]; mult[i] = mult[j]; mult[j] = t;
            }
    for (int i = 0; i < nroots; ++i)
        printf("%d %d\n", roots[i], mult[i]);
    return 0;
}


======================================== ./tuan2/b1(Black_Column).c ========================================

#include <stdio.h>
int ma[1001][1001];
int main(){
    int n , m;
    scanf("%d %d", &n , &m);
    int i,j;
    for( i= 0 ; i <n ; i++){
        for(j =0 ; j< m ; j++){
            scanf("%d", &ma[i][j]);
        }
    }
    int dem = 0 ;
    for( i =0 ; i <m ; i++){
        for(j =0 ; j < n ; j++){
            if(ma[j][i] != 1) break;
            if(j == n -1) dem++;

        }
    }
    printf("%d", dem);
    return 0;

}


======================================== ./tuan2/b2(Check_Queen_solution).c ========================================

#include <stdio.h>
int Qcheck(int arr[][101], int NxN){
    int  i , j ;
    for(i =0 ; i< NxN  ; i++){
        for(j = 0 ; j < NxN  ; j++){
            if(arr[i][j]== 1){
                int m ,n ;
                for(m = i+1 , n = j-1 ; m < NxN && n >= 0 ; m++ , n--) if(arr[m][n] == 1) return 0;
                for(m = i+1 , n = j+1 ; m < NxN && n < NxN ; m++ , n++) if(arr[m][n] == 1) return 0;
                for(m = i+1 , n = j ; m < NxN ; m++) if(arr[m][n] == 1) return 0;
                for(m = i , n = j+1 ; n < NxN ; n++) if(arr[m][n] == 1) return 0;


            }

            }
        }
        return 1 ;
}


int kq[100];
int arr[101][101] = {0};
int main(){
    int num;
    scanf("%d", &num);
    int i , j , k ;
    for( i =0 ; i < num ; i++){
        int NxN;
        scanf("%d", &NxN);
        for(j = 0 ; j < NxN ; j++){
            for(k =0 ; k< NxN ; k++){
                scanf("%d", &arr[j][k]);
            }
        }
        kq[i] = Qcheck(arr, NxN);
        
    }
    for( i =0 ; i < num ; i++) printf("%d\n", kq[i]);
    return 0;
}


======================================== ./tuan2/b3(Evaluate_expression_contains_operand).c ========================================

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define MOD 1000000007
char math[10001];
long long num[10001] ={0};
char op[5001] ;
int main(){
    fgets(math,10001,stdin);
    math[strcspn(math,"\n")]='\0';
    int length = strlen(math) ;
    if(math[0] == '+' || math[0] == '*' || math[length-1] =='+' || math[length-1] == '*'){
        printf("NOT_CORRECT");
        return 0;
    }
    int i;
    for( i= 0 ; i< length ; i++){
        if(math[i] == '*' || math[i] == '+'){
            if(math[i+1] == '*' || math[i+1] =='+'){
                printf("NOT_CORRECT");
                return 0;
            }
        }
    }
    char *ptr = math;
    int dem1 = 0 , dem2 = 0;
    while( *ptr != '\0'){
        num[dem1++] = strtoll(ptr,&ptr,10);
        if(*ptr != '\0'){
            op[dem2++] = *ptr;
            ptr++;
        }
    }
    for( i=0 ; i < dem2 ; i++){
        if(op[i] == '*'){
            num[i +1] = num[i] * num[i+1] % MOD;
            num[i] = 0 ;
        }
    }
    long long sum = 0 ; 
    for( i =0  ;i < dem1 ; i++){
        sum = (sum + num[i]) % MOD;
    }
    printf("%lld", sum % MOD);
    return 0;

}




======================================== ./tuan2/b4(Multiplication_of_2_matrices).c ========================================

#include <stdio.h>
int a[101][101] , b[101][101] , c[101][101] = {0};
int main(){
    int n , k ; 
    scanf("%d %d", &n , &k);
    int i , j ;
    for(i =0 ; i <n ; i++){
        for(j= 0 ; j< k ;j++){
            scanf("%d", &a[i][j]);
        }
    }
    int k1 , m;
    scanf("%d %d", &k1 , &m);
    for(i =0 ; i <k ; i++){
        for(j= 0 ; j< m ;j++){
            scanf("%d", &b[i][j]);
        }
    }
    for(i =0 ; i <n ; i++){
        for(j= 0 ; j< m ;j++){
            for(int h =0 ; h < k ; h++ ){
                c[i][j] += a[i][h]*b[h][j] ;


            }

        }
    }
    for(i =0 ; i <n ; i++){
        for(j= 0 ; j< m ;j++){
            printf("%d ", c[i][j]);
        }
        printf("\n");
    }

    return 0;

}


======================================== ./tuan2/b5(Bounding_rectangle).c ========================================

#include <stdio.h>
int arr[1001][4] ;
int main(){
    int n;
    scanf("%d", &n);
    int i ,j ;
    for( int i =0 ; i <n ;i++){
        for(j =0 ;j <4 ;j++){
            scanf("%d",&arr[i][j]);
        }
    }
    int x1 , y1 ,x2 ,y2 ;
    int temp1 =1001 , temp2 = 0 ;
    for(i =0 ; i < n ; i++){
        for(j =0 ; j <4 ; j+= 2){
            if(arr[i][j] < temp1) temp1 =arr[i][j];
            if(arr[i][j] > temp2) temp2 =arr[i][j];
        }
    }
    x1 = temp1 , x2 = temp2 ;
    temp1 =1001 , temp2 = 0 ;
    for(i =0 ; i < n ; i++){
        for(j =1 ; j <4 ; j+= 2){
            if(arr[i][j] < temp1) temp1 =arr[i][j];
            if(arr[i][j] > temp2) temp2 =arr[i][j];
        }
    }
    y1 = temp1 , y2 = temp2 ;
    int sum = (x2-x1)*(y2-y1);
    printf("%d", sum);
    return 0;


}


======================================== ./tuan2/b6(Report_student_doing_quiz_on_date).c ========================================

#include <stdio.h>
#include <string.h>
 typedef struct{
    int yyyy , mm , dd;
    int h , m , s;
    char user_id[10];
    int q_id;

 }sv;
int main(){
    sv  a[1000];
    int i =0 ;
    char line[100];
    while(1){
        fgets(line,100,stdin);
        line[strcspn(line,"\n")] = '\0';
        if( line[0] == '*') break;
        sscanf(line,"%d-%d-%d %d:%d:%d %s question%d ", &a[i].yyyy, &a[i].mm, &a[i].dd, &a[i].h, &a[i].m, &a[i].s, &a[i].user_id, &a[i].q_id);
        i++;
    }
    return 0;
    
}


======================================== ./tuan2/b7(Find_integer_solutions_to_Polynomial_Degree_3).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAX_ROOTS 3

long long cubic(int a, int b, int c, int x) {
    return (long long)x * x * x + (long long)a * x * x + (long long)b * x + c;
}

int find_divisors(int c, int divisors[]) {
    int count = 0;
    int abs_c = abs(c);
    for (int i = 1; i * i <= abs_c; ++i) {
        if (abs_c % i == 0) {
            divisors[count++] = i;
            if (i != abs_c / i)
                divisors[count++] = abs_c / i;
        }
    }
    if (c < 0) {
        int orig = count;
        for (int i = 0; i < orig; ++i)
            divisors[count++] = -divisors[i];
    }
    return count;
}

int main() {
    int a, b, c;
    if (scanf("%d %d %d", &a, &b, &c) != 3) {
        printf("NO SOLUTION\n");
        return 0;
    }
    int roots[MAX_ROOTS], mult[MAX_ROOTS], nroots = 0;
    int ca = a, cb = b, cc = c;
    int found = 0;
    int divisors[10000], dcount = 0;
    // Find all divisors of c (including negative)
    int abs_c = abs(c);
    for (int i = 1; i * (long long)i <= abs_c; ++i) {
        if (abs_c % i == 0) {
            divisors[dcount++] = i;
            if (i != abs_c / i) divisors[dcount++] = abs_c / i;
        }
    }
    for (int i = 0, orig = dcount; i < orig; ++i) divisors[dcount++] = -divisors[i];

    for (int k = 0; k < MAX_ROOTS; ++k) {
        int root = 0, multiplicity = 0;
        int found_root = 0;
        for (int i = 0; i < dcount; ++i) {
            int x = divisors[i];
            // Skip already used roots
            int skip = 0;
            for (int t = 0; t < nroots; ++t) if (roots[t] == x) skip = 1;
            if (skip) continue;
            long long val = (k == 0) ? ((long long)x * x * x + (long long)ca * x * x + (long long)cb * x + cc)
                            : (k == 1) ? ((long long)x * x + (long long)ca * x + cb)
                            : ((long long)x + ca);
            if (val == 0) {
                root = x;
                found_root = 1;
                break;
            }
        }
        if (!found_root) break;
        // Count multiplicity
        do {
            multiplicity++;
            if (k == 0) {
                int na = ca + root;
                int nb = cb + na * root;
                ca = na;
                cb = nb;
                cc = 0;
            } else if (k == 1) {
                int na = ca + root;
                ca = na;
                cb = 0;
            } else {
                ca = 0;
            }
            long long val = (k == 0) ? ((long long)root * root * root + (long long)ca * root * root + (long long)cb * root + cc)
                            : (k == 1) ? ((long long)root * root + (long long)ca * root + cb)
                            : ((long long)root + ca);
            if (val != 0) break;
        } while (multiplicity < 3);
        roots[nroots] = root;
        mult[nroots] = multiplicity;
        nroots++;
        found = 1;
    }
    int ok = 0;
    if (nroots == 3 && ca == 0 && cb == 0 && cc == 0) ok = 1;
    if (nroots == 2 && ca == 0 && cb == 0) ok = 1;
    if (nroots == 1 && ca == 0) ok = 1;
    if (!ok) {
        printf("NO SOLUTION\n");
        return 0;
    }
    for (int i = 0; i < nroots - 1; ++i)
        for (int j = i + 1; j < nroots; ++j)
            if (roots[i] > roots[j]) {
                int t = roots[i]; roots[i] = roots[j]; roots[j] = t;
                t = mult[i]; mult[i] = mult[j]; mult[j] = t;
            }
    for (int i = 0; i < nroots; ++i)
        printf("%d %d\n", roots[i], mult[i]);
    return 0;
}



======================================== ./tuan2/b8(Check_Sudoku).c ========================================

#include <stdio.h>

int check_row(int mat[9][9], int row) {
    int seen[10] = {0};
    for (int j = 0; j < 9; ++j) {
        int val = mat[row][j];
        if (val < 1 || val > 9 || seen[val]) return 0;
        seen[val] = 1;
    }
    return 1;
}

int check_col(int mat[9][9], int col) {
    int seen[10] = {0};
    for (int i = 0; i < 9; ++i) {
        int val = mat[i][col];
        if (val < 1 || val > 9 || seen[val]) return 0;
        seen[val] = 1;
    }
    return 1;
}

int check_square(int mat[9][9], int start_row, int start_col) {
    int seen[10] = {0};
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j) {
            int val = mat[start_row + i][start_col + j];
            if (val < 1 || val > 9 || seen[val]) return 0;
            seen[val] = 1;
        }
    return 1;
}

int is_sudoku(int mat[9][9]) {
    for (int i = 0; i < 9; ++i)
        if (!check_row(mat, i) || !check_col(mat, i))
            return 0;
    for (int i = 0; i < 9; i += 3)
        for (int j = 0; j < 9; j += 3)
            if (!check_square(mat, i, j))
                return 0;
    return 1;
}

int main() {
    int T;
    scanf("%d", &T);
    for (int t = 0; t < T; ++t) {
        int mat[9][9];
        for (int i = 0; i < 9; ++i)
            for (int j = 0; j < 9; ++j)
                scanf("%d", &mat[i][j]);
        printf("%d\n", is_sudoku(mat));
    }
    return 0;
}



======================================== ./tuan3/b1(Array_Equality).c ========================================

#include <stdio.h>
int arr1[1002] , arr2[1002] ;
int main(){
    int T ;
    scanf("%d", &T);
    int arr3[1001] = {0};
    int i , j;
    int dem = 0;
    for( i = 0 ;i < T ; i++){
        int n , m ;
        scanf("%d %d", &n , &m);
        for ( j =0 ; j < n ; j++) scanf("%d", &arr1[j]);
        for ( j =0 ; j < m ; j++) scanf("%d", &arr2[j]);
        if ( n != m){
            arr3[i] = 0 ;
            continue;
        }
        for(j =0 ; j <n ; j++){
            if(arr1[j] == arr2[j]) arr3[i] = 1;
            else{
                arr3[i] = 0;
                break;
            }

    }
    }
    for( i = 0 ; i < T ; i++) printf("%d\n", arr3[i]);
    return 0;

}


======================================== ./tuan3/b2(Basic_queries_on_array).c ========================================




======================================== ./tuan3/b3(Solve_degree_2_polynomial_equation).c ========================================

#include <stdio.h>
#include <math.h>
int main(){
    double a ,b , c;
    scanf("%lf %lf %lf", &a , &b , &c );
    double delta = b*b -4*a*c;
    if( a== 0){
        if( b== c | c== 0){
         printf("NO SOLUTION");
        return 0;   
        }
        printf("%.2lf", -c/b);
        return 0;
    }
    if( delta < 0){
        printf("NO SOLUTION");
        return 0;
    }
    if(delta == 0){
        printf("%.2lf", (-b)/(2*a));
        return 0;

    }
    else printf("%.2lf %.2lf", (-b-sqrt(delta))/(2*a) , (-b+sqrt(delta))/(2*a)  ) ;
    return 0;


}


======================================== ./tuan3/b4(k_Subsequence_even).c ========================================

#include <stdio.h>
int arr[100001];
int main(){
    int n , k;
    scanf("%d %d", &n , &k);
    int i , j ;
    for(i =0 ; i< n ; i++) scanf("%d", &arr[i]);
    int sum = 0 , dem = 0;
    for( i = 0 ; i <= n - k ; i++){
        for(j = 0 ; j < k ; j++){
            sum += arr[i+j];
        }
        if( sum % 2 == 0 ) dem++;
        sum = 0;

    }
    printf("%d", dem);
    return 0;

}


======================================== ./tuan3/b5(Find_all_perfect_square_in_a_sequence).c ========================================

#include <stdio.h>
#include <math.h>
int arr[1000001];
int main(){
    int n;
    scanf("%d", &n);
    int i,  dem =0 ;
    for( i =0 ; i< n ; i++){
        scanf("%d", &arr[i]);
        if( sqrt(arr[i]) == (int)sqrt(arr[i]) ) dem++;
    }
    printf("%d", dem);
    return 0;
}


======================================== ./tuan3/b6(Separate_the_integer_and_decimal_parts_of_a_float).c ========================================

#include <stdio.h>
int main(){
    double a;
    scanf("%lf", &a);
    int b = (int)a;
    if(b >a) b -= 1;
    double c = a - b ;
    printf("%d %.2f", b ,c);
    return 0;
}


======================================== ./tuan3/b7(Convert_a_TEXT_to_Upper-Case).c ========================================

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#define MAX 1000000
int main(){
    char arr[MAX];
     while (fgets(arr, MAX, stdin)){
    int i ;
    int k = 'A' - 'a';
    for( i=0 ; i < strlen(arr); i++){
        if('a' <= arr[i] && arr[i] <= 'z') arr[i] += k;
        
    }
    printf("%s", arr);
}
    return 0;
}


======================================== ./tuan3/b8(Basic_queries_on_array).c ========================================

#include <stdio.h>
#include <string.h>

int main() {
    int n;
    scanf("%d", &n);

    int a[10005];
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }

    char ch;
    while ((ch = getchar()) != '*' && ch != EOF);

    char cmd[50];
    while (1) {
        scanf("%s", cmd);
        if (strcmp(cmd, "***") == 0) break;

        if (strcmp(cmd, "find-max") == 0) {
            int max = a[0];
            for (int i = 1; i < n; i++)
                if (a[i] > max) max = a[i];
            printf("%d\n", max);
        } 
        
        else if (strcmp(cmd, "find-min") == 0) {
            int min = a[0];
            for (int i = 1; i < n; i++)
                if (a[i] < min) min = a[i];
            printf("%d\n", min);
        } 
        
        else if (strcmp(cmd, "sum") == 0) {
            int s = 0;
            for (int i = 0; i < n; i++)
                s += a[i];
            printf("%d\n", s);
        } 
        
        else if (strcmp(cmd, "find-max-segment") == 0) {
            int i, j;
            scanf("%d %d", &i, &j);
            i--; 
            j--; 
            int max = a[i];
            for (int k = i + 1; k <= j; k++)
                if (a[k] > max) max = a[k];
            printf("%d\n", max);
        }
    }

    return 0;
}



======================================== ./tuan3/bttuan3_202416969.c ========================================

#include <stdio.h>
#include <stdlib.h>

// Hàm Alloc_Cub(m, r, c)

int ***Alloc_Cub(int m, int r, int c) {
    int i, j;
    int ***a = (int ***)malloc(m * sizeof(int **));
    if (!a) return NULL;

    for (i = 0; i < m; i++) {
        a[i] = (int **)malloc(r * sizeof(int *));
        if (!a[i]) return NULL;
        for (j = 0; j < r; j++) {
            a[i][j] = (int *)calloc(c, sizeof(int));
            if (!a[i][j]) return NULL;
        }
    }
    return a;
}

//Hàm Free_Cub(...)
void Free_Cub(int ***a, int m, int r) {
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < r; j++)
            free(a[i][j]);
        free(a[i]);
    }
    free(a);
}

//* Hàm Realloc_Cub(...)

void Realloc_Cub(int ****p, int m, int r, int c, int m2, int r2, int c2) {
    int ***old = *p;
    int ***new = Alloc_Cub(m2, r2, c2);
    if (!new) return;
    int mm = (m < m2 ? m : m2);
    int rr = (r < r2 ? r : r2);
    int cc = (c < c2 ? c : c2);
    for (int i = 0; i < mm; i++)
        for (int j = 0; j < rr; j++)
            for (int k = 0; k < cc; k++)
                new[i][j][k] = old[i][j][k];

    Free_Cub(old, m, r);
    *p = new;
}

int main() {
    int m = 2, r = 3, c = 4;
    int ***a = Alloc_Cub(m, r, c);
    if (!a) return 1;

    // Gán giá trị mẫu
    for (int i = 0; i < m; i++)
        for (int j = 0; j < r; j++)
            for (int k = 0; k < c; k++)
                a[i][j][k] = i + j + k;

    printf(" Trước khi cấp phát lại \n");
    for (int i = 0; i < m; i++) {
        printf("M%d:\n", i);
        for (int j = 0; j < r; j++) {
            for (int k = 0; k < c; k++)
                printf("%3d ", a[i][j][k]);
            printf("\n");
        }
        printf("-----------------\n");
    }

    // Tái cấp phát mảng
    int m2 = 4, r2 = 4, c2 = 4;
    Realloc_Cub(&a, m, r, c, m2, r2, c2);

    printf("\n Sau khi cấp phát lại\n");
    for (int i = 0; i < m2; i++) {
        printf("M%d:\n", i);
        for (int j = 0; j < r2; j++) {
            for (int k = 0; k < c2; k++)
                printf("%3d ", a[i][j][k]);
            printf("\n");
        }
        printf("-----------------\n");
    }

    Free_Cub(a, m2, r2);
    return 0;
}



======================================== ./tuan4/b1(Compute_C_k_n).c ========================================

#include <stdio.h>
long long arr[1000][1000] = {0};
long long Ckn(int k , int n){
   if(k == 0 || k ==n) return 1;
   else if(k == 1) return n;
   if(arr[k][n] != 0) return arr[k][n] % 1000000007;
    arr[k][n] = (Ckn(k-1,n-1)+Ckn(k,n-1)) % 1000000007;
    return arr[k][n];
}
int main(){
    int k ,n ; 
    scanf("%d %d", &k , &n);
    printf("%lld", Ckn(k,n));
    return 0;
}


======================================== ./tuan4/b2(Subset_sum_of_elements_equal_to_B).c ========================================

#include <stdio.h>
int arr[101] = {0} ;
int a ,b ; 
int dem = 0;
int sum =0;
int Try(int k){
    for( int i =0 ; i<= 1 ; i++){
        if( i== 1) sum+= arr[k];
        if( sum > b){
            sum -= arr[k];
            continue;
        }
        if (k == a - 1) {
            if (sum == b) dem++;
            if (i == 1) sum -= arr[k]; 
        }

        else{
            Try(k+1);
            if( i == 1) sum -= arr[k];
        }


    }

}
int main(){
    scanf("%d %d", &a , &b);
    for( int i = 0 ; i < a ; i++) scanf("%d", &arr[i]);
    Try(0);
    printf("%d", dem);
    return 0;
}



======================================== ./tuan4/b3(Count_number_of_sudoku_solutions).c ========================================

#include <stdio.h>
int arr[10][10];
int dem =0 ;
int Check(int m , int n){
    for( int i =0 ; i < 9 ; i++){
        if(arr[m][n] == arr[i][n]&& arr[m][n] != 0&& i!= m)
        return 0;
    }
    for( int i =0 ; i < 9 ; i++){
        if(arr[m][n] == arr[m][i]&& arr[m][n] != 0 && i != n)
        return 0;
    }
    for(int i = m / 3 *3 ; i < m / 3 *3+3 ; i++){
        for(int j = n /3 *3 ; j < n /3 *3+3 ; j++){
            if(arr[m][n] == arr[i][j]&& arr[m][n] != 0 && (m!=i || n!= j))
            return 0;
        }
    }
    return 1;
}
void Try(int k1 , int k2){
    if(arr[k1][k2] == 0){
        for(int i = 1 ; i <= 9 ; i++){
            arr[k1][k2] = i ;
            if(Check(k1,k2)){
             if(k1 == 8 && k2 == 8 ) dem++;
             else if(k2 == 8) Try(k1+1, 0) ;
             else if(k2 < 8) Try(k1,k2+1) ;
            }
            arr[k1][k2] = 0 ;
        }
    }
    else if(arr[k1][k2] != 0){
        if(Check(k1,k2)){
        if(k1 == k2 && k1 == 8 ) dem++;
        else if(k2 == 8) Try(k1+1, 0) ;
        else if(k2 < 8) Try(k1,k2+1) ;
    }
    
}
}
int main(){
    for( int i =0 ; i< 9 ;i++){
        for(int j =0 ; j< 9; j++){
            scanf("%d", &arr[i][j]);
        }
    }
    Try(0,0);
    printf("%d", dem);
    return 0;
}



======================================== ./tuan4/b4(Permutation_generation).c ========================================

#include <stdio.h>
int n;
int arr[50]  = {0};
void solution(){
    int dem = 0;
    for(int i =0 ; i < n ;i++)
    printf("%d ", arr[i]);
    printf("\n");
    return;
}
int Check(){
    for(int i = 1 ; i < n ; i++ ){
        for(int j =0 ; j < i ; j++){
            if(arr[i] == arr[j]) return 0;
        }
    }
    return 1;
    
}
void Try(int k){
    for(int i =1 ; i<= n ; i++){
        arr[k] = i;  
        if(k == n -1){
            if (Check()){
             solution();
            }}
        else Try(k+1);
    }
}  

int main(){
    scanf("%d", &n);
    Try(0);
    return 0;
}


======================================== ./tuan4/b5(Convert_integer_to_binary_string).c ========================================

#include <stdio.h>
int n ;
void Binary( int n){
    if(n == 0 ){
        printf("0");
    }
    else if(n == 1 ){
        printf("1");
    }
    else{ Binary(n/2);
    printf("%d", n%2);}
    
}

int main(){
    scanf("%d", &n);
    Binary(n);
    return 0;
}


======================================== ./tuan4/b6(Binary_sequences_generation_without_consecutive_11).c ========================================

#include <stdio.h>
int n;
int arr[21] ={0};
void solution(){
    for( int i =0 ; i< n ;i++) printf("%d", arr[i]);
    printf("\n");
}
void Try(int k){
    for( int i =0 ; i <= 1 ; i++){
        arr[k] = i;
        if(arr[k] == 1 && arr[k-1] ==1 ) continue;
        if( k == n - 1) solution();
        else Try(k+1);
    }
}
int main(){
    scanf("%d", &n);
    Try(0);
    return 0;
}


======================================== ./tuan4/b7(Linear_Integer_Equation_coefficent_1).c ========================================

#include <stdio.h>
int n , m ;
int arr[11];
int sum = 0;
void solution(){
    for(int i=0 ;i <n ; i++)
    printf("%d ",arr[i]);
    printf("\n");
}
void Try( int k){
    for(int i = 1 ; i <= m -n + 1 ;i++){
        arr[k] = i;
        sum += i;
        if(k == n -1 ){
            if(sum == m) solution();
        }
        else if(sum >= m){
            sum -= i;
            continue;
        }
        else Try(k+1);
        sum -=i;

    }
}
int main(){
    scanf("%d %d", &n ,&m);
    Try(0);
    return 0;
}


======================================== ./tuan4/b8(Count_number_of_Queen_solutions_with_some_specified_queens).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
int arr[13][13] = {0};
int n;
int dem = 0;
int Check(int r, int c){
    for( int i =0 ; i < n ; i++){
        if(i!= c && arr[r][i] == 1) return 0;
    }
    for(int i =0 ; i < n ; i++ ){
        if(i!= r && arr[i][c] == 1) return 0;
    }
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            if(arr[i][j] == 1){
                if(i == r && j == c) continue;
                if(abs(i - r) == abs(j - c)) return 0;
            }
        }
    }

    return 1;
}

void TryRow(int r){
    if(r == n){
        dem++;
        return;
    }

    int preset_col = -1;
    for(int j = 0; j < n; ++j){
        if(arr[r][j] == 1){ preset_col = j; break; }
    }
    if(preset_col != -1){
        if(Check(r, preset_col)) TryRow(r+1);
        return;
    }
    for(int j = 0; j < n; ++j){
        if(Check(r, j)){
            arr[r][j] = 1;
            TryRow(r+1);
            arr[r][j] = 0;
        }
    }
}
int main(){
    scanf("%d", &n);
    for( int i =0 ; i <n ; i++){
        for(int j = 0 ; j < n ; j++ ){
            scanf("%d", &arr[i][j]);
        }
    }

    for(int i = 0; i < n; ++i){
        for(int j = 0; j < n; ++j){
            if(arr[i][j] == 1){
                if(!Check(i,j)){
                    printf("0");
                    return 0;
                }
            }
        }
    }

    TryRow(0);
    printf("%d", dem);
    return 0;

}



======================================== ./tuan5/b1(Hanoi_Tower).c ========================================

#include <stdio.h>
int n , A , B , C , D ;
int dem = 0;
int Hanoi(int n , int A, int B, int C, int D ){
    dem++;
    if(n==1){
        if(D!= 0 ) printf("%d %d\n", A, B);
        return dem;
    }
    Hanoi(n-1,A,C,B,D);
    if(D!=0) printf("%d %d\n", A,B);
    Hanoi(n-1,C,B,A,D);
}

int main(){
    scanf("%d %d %d %d", &n ,&A, &B, &C);
    Hanoi(n,A,B,C,0);
    printf("%d\n",dem);
    dem = 0;
    Hanoi(n,A,B,C,1);
    return 0;
}


======================================== ./tuan5/b2(Count_Solutions_TSP).c ========================================

#include <stdio.h>
#include <limits.h>
int n, maxdis;
int arr[101][101];
int dis = 0 ;
int dem = 0;
int C[101]; //tp di qua 
int visited[101] = {0};
void Try( int i){
    for( int j =1 ; j < n ; j++){
        if( visited[j] == 0){
            visited[j] = 1;
            C[i] =j ;
            dis += arr[C[i-1]][C[i]];
            if( i < n - 1 ) Try(i+1);
            else if(i == n -1){
                if(maxdis - dis - arr[C[n-1]][C[0]] >= 0) dem++;
            }
        }
        else continue;
        visited[j] = 0 ; 
        dis -= arr[C[i-1]][C[i]];


    }
}
int main(){
    scanf("%d %d", &n, &maxdis);
    for( int i =0 ; i < n ; i++ ){
        for( int j =0 ; j < n ;j++){
            scanf("%d", &arr[i][j]);
        }
    }
    visited[0] = 1;
    Try(1);
    printf("%d", dem);
 return 0;
}


======================================== ./tuan5/b3(Binary_sequence_generation).c ========================================

#include <stdio.h>
int n ; 
int arr[21];
void solution(){
    for( int i = 0 ; i < n ; i++){
        printf("%d", arr[i]);
    }
    printf("\n");
}
void Try( int k){
    for( int i =0 ; i <=1 ; i++){
        arr[k] = i ;
        if (k < n -1 ) Try( k +1);
        else if( k == n -1 ) solution();

    }
}
int main(){
    scanf("%d", &n);
    Try(0);
    return 0;
}


======================================== ./tuan5/b4(Fibonacci).c ========================================

#include <stdio.h>
int n, arr[100002]= {0};
long long Fun(int n){
    if(n < 0) return 0;
    if(n==0) return 0;
    else if(n==1) return 1;
    else if(n>=2){
       if (arr[n] !=0) return arr[n];
        else{
        arr[n]=(Fun(n-1)+Fun(n-2))%1000000007;
            return arr[n];
        }
    }
    return 0;
}
int main()
{
    scanf("%d",&n);
    printf("%lld",Fun(n));
    return 0;

}



======================================== ./tuan5/b5(Greatest_Common_Divisor).c ========================================

#include <stdio.h>
int GCD( int a , int b){
    if(a%b == 0) return b;
    a = a % b ;
    return GCD(b,a);
}
int main(){
    int a , b; 
    scanf("%d %d", &a , &b);
    printf("%d", GCD(a,b));
    return 0;
}


======================================== ./tuan5/b6(TSP).c ========================================

#include <stdio.h>
#include <limits.h>
int mindis = INT_MAX;
int n, dis = 0 ;
int arrdis[105][105];
int last[105];
int visited[105] = {0};
void Try( int i){
    for( int j = 1 ; j < n ; j++){
        if(visited[j] == 0 ){
            visited[j] = 1 ;
            last[i] = j ;
            dis += arrdis[last[i-1]][last[i]];
            if( dis > mindis){
                visited[j] = 0;
                dis -= arrdis[last[i -1 ]][last[i]];
                continue;
            }
            if( i < n -1 ) Try(i+1);
            else if(i == n-1){
                if( mindis > dis + arrdis[last[n-1]][last[0]])
                mindis = dis + arrdis[last[n-1]][last[0]];
            }
        }
        else continue;
        visited[j] = 0;
        dis -= arrdis[last[i -1 ]][last[i]];
    }

}
int main(){
    scanf("%d", &n);
    for( int i = 0 ; i <n ; i++){
        for( int j =0 ; j< n ; j++){
            scanf("%d", &arrdis[i][j]);
        }
    }
    visited[0] = 1 ;
    Try(1);
    printf("%d", mindis);
    return 0;
}


======================================== ./tuan6/b1(WATER_JUGS).c ========================================




======================================== ./tuan6/b2(Simulation_Stack).c ========================================




======================================== ./tuan6/b3(Simulation_Queue).c ========================================




======================================== ./tuan6/b4(Polynomial_Manipulation).c ========================================




======================================== ./tuan6/b5(Parenthesis).c ========================================




======================================== ./tuan6/b6(Maze).c ========================================




======================================== ./tuan6/b7(Linked_List_Manipulation).c ========================================




======================================== ./tuan6/b8(Delete_number).c ========================================



