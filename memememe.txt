
======================================== ./de thi thu/b1.c ========================================

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// sort
static void merge(char *base, char *temp, size_t left, size_t mid, size_t right,
                  size_t size, int (*compare)(const void *, const void *)) {
    size_t i = left, j = mid, k = left;

    while (i < mid && j < right) {
        if (compare(base + i * size, base + j * size) <= 0) {
            memcpy(temp + k * size, base + i * size, size);
            i++;
        } else {
            memcpy(temp + k * size, base + j * size, size);
            j++;
        }
        k++;
    }

    while (i < mid) {
        memcpy(temp + k * size, base + i * size, size);
        i++;
        k++;
    }

    while (j < right) {
        memcpy(temp + k * size, base + j * size, size);
        j++;
        k++;
    }

    for (i = left; i < right; i++) {
        memcpy(base + i * size, temp + i * size, size);
    }
}

static void mergesort_rec(char *base, char *temp, size_t left, size_t right,
                          size_t size,
                          int (*compare)(const void *, const void *)) {
    if (right - left <= 1)
        return;

    size_t mid = (left + right) / 2;

    mergesort_rec(base, temp, left, mid, size, compare);
    mergesort_rec(base, temp, mid, right, size, compare);
    merge(base, temp, left, mid, right, size, compare);
}

void mergesort(void *base, size_t nitems, size_t size,
               int (*compare)(const void *, const void *)) {
    if (nitems < 2)
        return;

    char *temp = malloc(nitems * size);
    if (!temp)
        return;

    mergesort_rec((char *)base, temp, 0, nitems, size, compare);

    free(temp);
}
//
typedef struct {
    int id;
    char email[21];
} data;
int compare(const void *a, const void *b) {
    const data *x = (const data *)a;
    const data *y = (const data *)b;
    return strcmp(x->email, y->email);
}
int main() {
    int n;
    scanf("%d", &n);
    data sv[n];
    for (int i = 0; i < n; i++) {
        scanf("%d %s", &sv[i].id, sv[i].email);
    }
    mergesort(sv, n, sizeof(data), compare);
    for (int i = 0; i < n; i++) {
        printf("%d %s\n", sv[i].id, sv[i].email);
    }
    return 0;
}


======================================== ./de thi thu/b2.c ========================================




======================================== ./de thi thu/mersort.c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void merge(char *base, char *temp, size_t left, size_t mid, size_t right,
                  size_t size, int (*compare)(const void *, const void *)) {
    size_t i = left, j = mid, k = left;

    while (i < mid && j < right) {
        if (compare(base + i * size, base + j * size) <= 0) {
            memcpy(temp + k * size, base + i * size, size);
            i++;
        } else {
            memcpy(temp + k * size, base + j * size, size);
            j++;
        }
        k++;
    }

    while (i < mid) {
        memcpy(temp + k * size, base + i * size, size);
        i++;
        k++;
    }

    while (j < right) {
        memcpy(temp + k * size, base + j * size, size);
        j++;
        k++;
    }

    for (i = left; i < right; i++) {
        memcpy(base + i * size, temp + i * size, size);
    }
}

static void mergesort_rec(char *base, char *temp, size_t left, size_t right,
                          size_t size,
                          int (*compare)(const void *, const void *)) {
    if (right - left <= 1)
        return;

    size_t mid = (left + right) / 2;

    mergesort_rec(base, temp, left, mid, size, compare);
    mergesort_rec(base, temp, mid, right, size, compare);
    merge(base, temp, left, mid, right, size, compare);
}

void mergesort(void *base, size_t nitems, size_t size,
               int (*compare)(const void *, const void *)) {
    if (nitems < 2)
        return;

    char *temp = malloc(nitems * size);
    if (!temp)
        return;

    mergesort_rec((char *)base, temp, 0, nitems, size, compare);

    free(temp);
}



======================================== ./racthai/rac.c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int key;
    struct Node *left;
    struct Node *right;
} Node;

Node *createNode(int key) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->key = key;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

Node *insert(Node *root, int key) {
    if (root == NULL) {
        return createNode(key);
    }
    if (key < root->key) {
        root->left = insert(root->left, key);
    } else if (key > root->key) {
        root->right = insert(root->right, key);
    }
    // If key already exists, do nothing
    return root;
}

Node *findMin(Node *root) {
    while (root->left != NULL) {
        root = root->left;
    }
    return root;
}

Node *removeNode(Node *root, int key) {
    if (root == NULL) {
        return root;
    }
    if (key < root->key) {
        root->left = removeNode(root->left, key);
    } else if (key > root->key) {
        root->right = removeNode(root->right, key);
    } else {
        // Node with only one child or no child
        if (root->left == NULL) {
            Node *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            Node *temp = root->left;
            free(root);
            return temp;
        }
        // Node with two children: Get the inorder successor (smallest in the
        // right subtree)
        Node *temp = findMin(root->right);
        root->key = temp->key;
        root->right = removeNode(root->right, temp->key);
    }
    return root;
}

void preorderTraversal(Node *root) {
    if (root != NULL) {
        printf("%d ", root->key);
        preorderTraversal(root->left);
        preorderTraversal(root->right);
    }
}

void postorderTraversal(Node *root) {
    if (root != NULL) {
        postorderTraversal(root->left);
        postorderTraversal(root->right);
        printf("%d ", root->key);
    }
}

int main() {
    Node *root = NULL;
    char line[256];
    while (fgets(line, sizeof(line), stdin)) {
        line[strcspn(line, "\n")] = 0; // Remove newline
        if (strcmp(line, "#") == 0) {
            break;
        }
        char command[20];
        int key;
        if (sscanf(line, "%s %d", command, &key) == 2) {
            if (strcmp(command, "insert") == 0) {
                root = insert(root, key);
            } else if (strcmp(command, "remove") == 0) {
                root = removeNode(root, key);
            }
        } else if (strcmp(line, "preorder") == 0) {
            preorderTraversal(root);
            printf("\n");
        } else if (strcmp(line, "postorder") == 0) {
            postorderTraversal(root);
            printf("\n");
        }
    }
    // Free the tree memory if needed, but for simplicity, omit here
    return 0;
}


======================================== ./tuan1/b1(Text_Replacement).c ========================================

#include <stdio.h>
#include <string.h>
char p1[50], p2[50], t[10001], ketqua[1001];
int main() {
    fgets(p1, 50, stdin);
    p1[strcspn(p1, "\n")] = '\0';
    fgets(p2, 50, stdin);
    p2[strcspn(p2, "\n")] = '\0';
    fgets(t, 1001, stdin);
    t[strcspn(t, "\n")] = '\0';
    int i = 0, post = 0;
    while (t[i] != '\0') {
        if (strncmp(&t[i], p1, strlen(p1)) == 0) {
            strcpy(&ketqua[post], p2);
            post += strlen(p2);
            i += strlen(p1);
        } else {
            ketqua[post] = t[i];
            i++;
            post++;
        }
    }
    for (int i = 0; i < strlen(ketqua); i++)
        printf("%c", ketqua[i]);
    return 0;
}
/*
Dữ liệu
· Dòng 1: xâu P1
· Dòng 2: xâu P2
· Dòng 3: văn bản T
Kết quả:
· Ghi văn bản T sau khi thay thế
Ví dụ
Dữ liệu
AI
Artificial Intelligence
Recently, AI is a key technology. AI enable efficient operations in many fields.
Kết quả
Recently, Artificial Intelligence is a key technology. Artificial Intelligence
enable efficient operations in many fields.
*/


======================================== ./tuan1/b2(Count_words).c ========================================

#include <stdio.h>

int main() {
    char ch;
    int i = 0, inword = 0;
    while ((ch = getchar()) != EOF) {
        if (ch == ' ' || ch == '\n' || ch == '\t')
            inword = 0;
        else {
            if (inword == 0) {
                i++;
                inword = 1;
            }
        }
    }
    printf("%d", i);
    return 0;
}
/*
Input
Hanoi University Of Science and Technology
School of Information and Communication Technology


Output
12
*/


======================================== ./tuan1/b3(Find_all_divisor_of_an_integer ).c ========================================

#include <math.h>
#include <stdio.h>

int main() {
    long long n;
    scanf("%lld", &n);
    int i, arr[10000];
    int dem = 0;
    for (i = 1; i <= sqrt(n); i++) {
        if (n % i == 0) {
            arr[dem] = i;
            dem++;
            if (n / i != i) {
                arr[dem] = n / i;
                dem++;
            }
        }
    }
    for (i = 0; i < dem; i++) {
        for (int j = i + 1; j < dem; j++) {
            if (arr[i] < arr[j]) {
                int temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
            }
        }
    }
    for (int i = 0; i < dem; i++)
        printf("%d ", -arr[i]);
    for (int i = dem - 1; i >= 0; i--)
        printf("%d ", arr[i]);
    return 0;
}


======================================== ./tuan1/b4(Sum_Array).c ========================================

#include <stdio.h>
int main() {
    int n;
    scanf("%d", &n);
    int i, arr[n];
    int sum = 0;
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
        sum += arr[i];
    }
    printf("%d", sum);
    return 0;
}
/*
Input
4
1 2 3 4
Output
10
*/


======================================== ./tuan1/b5(Replace_characters_in_string).c ========================================

#include <stdio.h>
#include <string.h>

int main(void) {
    char arr[20];
    char a, b;
    int i;
    if (scanf("%19s", arr) != 1) {
        return 1;
    }
    if (scanf(" %c %c", &a, &b) != 2) {
        return 1;
    }
    for (i = 0; i < (int)strlen(arr); i++) {
        if (arr[i] == a) {
            arr[i] = b;
        }
    }
    printf("%s\n", arr);
    return 0;
}
/*
- input: “papa”, ‘p’, ‘m’
- output: “mama”
*/


======================================== ./tuan2/b1(Black_Column).c ========================================

#include <stdio.h>
int ma[1001][1001];
int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    int i, j;
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            scanf("%d", &ma[i][j]);
        }
    }
    int dem = 0;
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            if (ma[j][i] != 1)
                break;
            if (j == n - 1)
                dem++;
        }
    }
    printf("%d", dem);
    return 0;
}
/*
Input
4 4
1 0 1 0
1 1 1 0
1 0 1 1
1 1 1 1

Ouput
2
*/



======================================== ./tuan2/b2(Check_Queen_solution).c ========================================

#include <stdio.h>
int Qcheck(int arr[][101], int NxN) {
    int i, j;
    for (i = 0; i < NxN; i++) {
        for (j = 0; j < NxN; j++) {
            if (arr[i][j] == 1) {
                int m, n;
                for (m = i + 1, n = j - 1; m < NxN && n >= 0; m++, n--)
                    if (arr[m][n] == 1)
                        return 0;
                for (m = i + 1, n = j + 1; m < NxN && n < NxN; m++, n++)
                    if (arr[m][n] == 1)
                        return 0;
                for (m = i + 1, n = j; m < NxN; m++)
                    if (arr[m][n] == 1)
                        return 0;
                for (m = i, n = j + 1; n < NxN; n++)
                    if (arr[m][n] == 1)
                        return 0;
            }
        }
    }
    return 1;
}

int kq[100];
int arr[101][101] = {0};
int main() {
    int num;
    scanf("%d", &num);
    int i, j, k;
    int dem = 0;
    for (i = 0; i < num; i++) {
        dem++;
        int NxN;
        scanf("%d", &NxN);
        for (j = 0; j < NxN; j++) {
            for (k = 0; k < NxN; k++) {
                scanf("%d", &arr[j][k]);
            }
        }
        kq[i] = Qcheck(arr, NxN);
    }
    for (i = 0; i < num; i++)
        printf("%d\n", kq[i]);
    return 0;
}
/*
Input
2
4
0 1 0 0
0 0 0 1
1 0 0 0
0 0 1 0
4
0 1 0 0
0 0 0 0
1 0 0 1
0 0 1 0
Output
1
0
*/


======================================== ./tuan2/b3(Evaluate_expression_contains_operand).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MOD 1000000007

char math[1000001];
long long num[1000001] = {0};
char op[100001];

int main() {
    fgets(math, 1000001, stdin);
    math[strcspn(math, "\n")] = '\0';
    int length = strlen(math);

    if (math[0] == '+' || math[0] == '*' || math[length - 1] == '+' ||
        math[length - 1] == '*') {
        printf("NOT_CORRECT");
        return 0;
    }

    for (int i = 0; i < length - 1; i++) {
        if ((math[i] == '*' || math[i] == '+') &&
            (math[i + 1] == '*' || math[i + 1] == '+')) {
            printf("NOT_CORRECT");
            return 0;
        }
    }

    char *ptr = math;
    int dem1 = 0, dem2 = 0;
    while (*ptr != '\0') {
        num[dem1++] = strtol(ptr, &ptr, 10);
        if (*ptr != '\0') {
            op[dem2++] = *ptr;
            ptr++;
        }
    }

    long long sum = 0;
    long long current = num[0];
    for (int i = 0; i < dem2; i++) {
        if (op[i] == '*') {
            current = (current * num[i + 1]) % MOD;
        } else {
            sum = (sum + current) % MOD;
            current = num[i + 1];
        }
    }
    sum = (sum + current) % MOD;

    printf("%lld", sum);
    return 0;
}
/*
Input
5+7*3*10*10
Output
2105
Input
5*+ 7*3*10*10
Output
NOT_CORRECT
*/


======================================== ./tuan2/b4(Multiplication_of_2_matrices).c ========================================

#include <stdio.h>
int a[101][101], b[101][101], c[101][101] = {0};
int main() {
    int n, k;
    scanf("%d %d", &n, &k);
    int i, j;
    for (i = 0; i < n; i++) {
        for (j = 0; j < k; j++) {
            scanf("%d", &a[i][j]);
        }
    }
    int k1, m;
    scanf("%d %d", &k1, &m);
    for (i = 0; i < k; i++) {
        for (j = 0; j < m; j++) {
            scanf("%d", &b[i][j]);
        }
    }
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            for (int h = 0; h < k; h++) {
                c[i][j] += a[i][h] * b[h][j];
            }
        }
    }
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            printf("%d ", c[i][j]);
        }
        printf("\n");
    }

    return 0;
}
/*
Input
2 3
1 2 3
4 5 6
3 4
1 1 1 1
2 2 2 2
3 3 3 3

Output
14 14 14 14
32 32 32 32
*/


======================================== ./tuan2/b5(Bounding_rectangle).c ========================================

#include <stdio.h>
int arr[1001][4];
int main() {
    int n;
    scanf("%d", &n);
    int i, j;
    for (int i = 0; i < n; i++) {
        for (j = 0; j < 4; j++) {
            scanf("%d", &arr[i][j]);
        }
    }
    int x1, y1, x2, y2;
    int temp1 = 1001, temp2 = 0;
    for (i = 0; i < n; i++) {
        for (j = 0; j < 4; j += 2) {
            if (arr[i][j] < temp1)
                temp1 = arr[i][j];
            if (arr[i][j] > temp2)
                temp2 = arr[i][j];
        }
    }
    x1 = temp1, x2 = temp2;
    temp1 = 1001, temp2 = 0;
    for (i = 0; i < n; i++) {
        for (j = 1; j < 4; j += 2) {
            if (arr[i][j] < temp1)
                temp1 = arr[i][j];
            if (arr[i][j] > temp2)
                temp2 = arr[i][j];
        }
    }
    y1 = temp1, y2 = temp2;
    int sum = (x2 - x1) * (y2 - y1);
    printf("%d", sum);
    return 0;
}
/*
Dữ liệu
3
2 4 2 7
3 2 4 7
1 2 5 2
Kết quả
20
*/


======================================== ./tuan2/b6(Report_student_doing_quiz_on_date).c ========================================


#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define MAX 50000

typedef struct {
    char date[11];
    int count;
} DayCount;

int cmp_daycount(const void *a, const void *b) {
    return strcmp(((const DayCount *)a)->date, ((const DayCount *)b)->date);
}

int main() {
    char line[256];
    DayCount days[MAX];
    int n = 0;

    while (fgets(line, sizeof(line), stdin)) {
        if (line[0] == '*')
            break;
        char date[11];
        sscanf(line, "%10s", date);
        int found = 0;
        for (int i = 0; i < n; ++i) {
            if (strcmp(days[i].date, date) == 0) {
                days[i].count++;
                found = 1;
                break;
            }
        }
        if (!found) {
            strcpy(days[n].date, date);
            days[n].count = 1;
            n++;
        }
    }

    qsort(days, n, sizeof(DayCount), cmp_daycount);

    for (int i = 0; i < n; ++i) {
        printf("%s %d\n", days[i].date, days[i].count);
    }
    return 0;
}
/*
Input
2022-01-02 10:30:24 dungpq question1
2022-01-03 11:30:24 dungpq question1
2022-02-01 03:30:20 viettq question2
2022-02-01 03:35:20 viettq question1
2022-03-01 03:30:20 viettq question7
2022-01-02 11:20:24 viettq question2
*
Output
2022-01-02 2
2022-01-03 1
2022-02-01 2
2022-03-01 1
*/



======================================== ./tuan2/b7(Find_integer_solutions_to_Polynomial_Degree_3).c ========================================

#include <math.h>
#include <stdio.h>
#include <stdlib.h>


#define MAX_ROOTS 3

long long cubic(int a, int b, int c, int x) {
    return (long long)x * x * x + (long long)a * x * x + (long long)b * x + c;
}

int find_divisors(int c, int divisors[]) {
    int count = 0;
    int abs_c = abs(c);
    for (int i = 1; i * i <= abs_c; ++i) {
        if (abs_c % i == 0) {
            divisors[count++] = i;
            if (i != abs_c / i)
                divisors[count++] = abs_c / i;
        }
    }
    if (c < 0) {
        int orig = count;
        for (int i = 0; i < orig; ++i)
            divisors[count++] = -divisors[i];
    }
    return count;
}

int main() {
    int a, b, c;
    if (scanf("%d %d %d", &a, &b, &c) != 3) {
        printf("NO SOLUTION\n");
        return 0;
    }
    int roots[MAX_ROOTS], mult[MAX_ROOTS], nroots = 0;
    int ca = a, cb = b, cc = c;
    int found = 0;
    int divisors[10000], dcount = 0;
    // Find all divisors of c (including negative)
    int abs_c = abs(c);
    for (int i = 1; i * (long long)i <= abs_c; ++i) {
        if (abs_c % i == 0) {
            divisors[dcount++] = i;
            if (i != abs_c / i)
                divisors[dcount++] = abs_c / i;
        }
    }
    for (int i = 0, orig = dcount; i < orig; ++i)
        divisors[dcount++] = -divisors[i];

    for (int k = 0; k < MAX_ROOTS; ++k) {
        int root = 0, multiplicity = 0;
        int found_root = 0;
        for (int i = 0; i < dcount; ++i) {
            int x = divisors[i];
            // Skip already used roots
            int skip = 0;
            for (int t = 0; t < nroots; ++t)
                if (roots[t] == x)
                    skip = 1;
            if (skip)
                continue;
            long long val =
                (k == 0)   ? ((long long)x * x * x + (long long)ca * x * x +
                            (long long)cb * x + cc)
                : (k == 1) ? ((long long)x * x + (long long)ca * x + cb)
                           : ((long long)x + ca);
            if (val == 0) {
                root = x;
                found_root = 1;
                break;
            }
        }
        if (!found_root)
            break;
        // Count multiplicity
        do {
            multiplicity++;
            if (k == 0) {
                int na = ca + root;
                int nb = cb + na * root;
                ca = na;
                cb = nb;
                cc = 0;
            } else if (k == 1) {
                int na = ca + root;
                ca = na;
                cb = 0;
            } else {
                ca = 0;
            }
            long long val =
                (k == 0)
                    ? ((long long)root * root * root +
                       (long long)ca * root * root + (long long)cb * root + cc)
                : (k == 1)
                    ? ((long long)root * root + (long long)ca * root + cb)
                    : ((long long)root + ca);
            if (val != 0)
                break;
        } while (multiplicity < 3);
        roots[nroots] = root;
        mult[nroots] = multiplicity;
        nroots++;
        found = 1;
    }
    int ok = 0;
    if (nroots == 3 && ca == 0 && cb == 0 && cc == 0)
        ok = 1;
    if (nroots == 2 && ca == 0 && cb == 0)
        ok = 1;
    if (nroots == 1 && ca == 0)
        ok = 1;
    if (!ok) {
        printf("NO SOLUTION\n");
        return 0;
    }
    for (int i = 0; i < nroots - 1; ++i)
        for (int j = i + 1; j < nroots; ++j)
            if (roots[i] > roots[j]) {
                int t = roots[i];
                roots[i] = roots[j];
                roots[j] = t;
                t = mult[i];
                mult[i] = mult[j];
                mult[j] = t;
            }
    for (int i = 0; i < nroots; ++i)
        printf("%d %d\n", roots[i], mult[i]);
    return 0;
}
/*
Input
-1  -1  -2
Output
NO SOLUTION

Input
-6 11 -6
Output
1 1
2 1
3 1

Input
8  5  -50
Output
-5  2
2   1
*/


======================================== ./tuan2/b8(Check_Sudoku).c ========================================

#include <stdio.h>

int check_row(int mat[9][9], int row) {
    int seen[10] = {0};
    for (int j = 0; j < 9; ++j) {
        int val = mat[row][j];
        if (val < 1 || val > 9 || seen[val])
            return 0;
        seen[val] = 1;
    }
    return 1;
}

int check_col(int mat[9][9], int col) {
    int seen[10] = {0};
    for (int i = 0; i < 9; ++i) {
        int val = mat[i][col];
        if (val < 1 || val > 9 || seen[val])
            return 0;
        seen[val] = 1;
    }
    return 1;
}

int check_square(int mat[9][9], int start_row, int start_col) {
    int seen[10] = {0};
    for (int i = 0; i < 3; ++i)
        for (int j = 0; j < 3; ++j) {
            int val = mat[start_row + i][start_col + j];
            if (val < 1 || val > 9 || seen[val])
                return 0;
            seen[val] = 1;
        }
    return 1;
}

int is_sudoku(int mat[9][9]) {
    for (int i = 0; i < 9; ++i)
        if (!check_row(mat, i) || !check_col(mat, i))
            return 0;
    for (int i = 0; i < 9; i += 3)
        for (int j = 0; j < 9; j += 3)
            if (!check_square(mat, i, j))
                return 0;
    return 1;
}

int main() {
    int T;
    scanf("%d", &T);
    for (int t = 0; t < T; ++t) {
        int mat[9][9];
        for (int i = 0; i < 9; ++i)
            for (int j = 0; j < 9; ++j)
                scanf("%d", &mat[i][j]);
        printf("%d\n", is_sudoku(mat));
    }
    return 0;
}
/*
Input
2
1 2 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 1 4 3 6 5 8 9 7
3 6 5 8 9 7 2 1 4
8 9 7 2 1 4 3 6 5
5 3 1 6 7 8 9 4 2
9 7 2 5 4 1 6 3 8
6 4 8 9 3 2 5 7 1
1 2 3 4 5 6 7 8 9
4 5 6 7 8 9 1 2 3
7 8 9 1 2 3 4 5 6
2 1 4 3 6 5 8 9 7
3 6 5 8 9 7 2 1 4
8 9 7 2 1 4 3 6 5
5 3 1 6 7 8 9 4 2
9 7 8 5 4 2 6 3 1
4 4 2 9 3 1 5 7 8

Output
1
0
*/


======================================== ./tuan3/b1(Array_Equality).c ========================================

#include <stdio.h>
int arr1[1002], arr2[1002];
int main() {
    int T;
    scanf("%d", &T);
    int arr3[1001] = {0};
    int i, j;
    int dem = 0;
    for (i = 0; i < T; i++) {
        int n, m;
        scanf("%d %d", &n, &m);
        for (j = 0; j < n; j++)
            scanf("%d", &arr1[j]);
        for (j = 0; j < m; j++)
            scanf("%d", &arr2[j]);
        if (n != m) {
            arr3[i] = 0;
            continue;
        }
        for (j = 0; j < n; j++) {
            if (arr1[j] == arr2[j])
                arr3[i] = 1;
            else {
                arr3[i] = 0;
                break;
            }
        }
    }
    for (i = 0; i < T; i++)
        printf("%d\n", arr3[i]);
    return 0;
}
/*
Input
3
3 3
1 2 3
1 2 3
4 2
1 2 3 4
1 2
3 3
2 4 1
2 3 1
Output
1
0
0
*/


======================================== ./tuan3/b2(Basic_queries_on_array).c ========================================

#include <stdio.h>
#include <string.h>

int main() {
    int n;
    scanf("%d", &n);

    int a[10005];
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }

    char ch;
    while ((ch = getchar()) != '*' && ch != EOF)
        ;

    char cmd[50];
    while (1) {
        scanf("%s", cmd);
        if (strcmp(cmd, "***") == 0)
            break;

        if (strcmp(cmd, "find-max") == 0) {
            int max = a[0];
            for (int i = 1; i < n; i++)
                if (a[i] > max)
                    max = a[i];
            printf("%d\n", max);
        }

        else if (strcmp(cmd, "find-min") == 0) {
            int min = a[0];
            for (int i = 1; i < n; i++)
                if (a[i] < min)
                    min = a[i];
            printf("%d\n", min);
        }

        else if (strcmp(cmd, "sum") == 0) {
            int s = 0;
            for (int i = 0; i < n; i++)
                s += a[i];
            printf("%d\n", s);
        }

        else if (strcmp(cmd, "find-max-segment") == 0) {
            int i, j;
            scanf("%d %d", &i, &j);
            i--;
            j--;
            int max = a[i];
            for (int k = i + 1; k <= j; k++)
                if (a[k] > max)
                    max = a[k];
            printf("%d\n", max);
        }
    }

    return 0;
}
/*
Input
5
1 4 3 2 5
*
find-max
find-min
find-max-segment 1 3
find-max-segment 2 5
sum
***

Output
5
1
4
5
15
*/


======================================== ./tuan3/b3(Solve_degree_2_polynomial_equation).c ========================================

#include <math.h>
#include <stdio.h>

int main() {
    double a, b, c;
    scanf("%lf %lf %lf", &a, &b, &c);
    double delta = b * b - 4 * a * c;
    if (a == 0) {
        if (b == c | c == 0) {
            printf("NO SOLUTION");
            return 0;
        }
        printf("%.2lf", -c / b);
        return 0;
    }
    if (delta < 0) {
        printf("NO SOLUTION");
        return 0;
    }
    if (delta == 0) {
        printf("%.2lf", (-b) / (2 * a));
        return 0;

    } else
        printf("%.2lf %.2lf", (-b - sqrt(delta)) / (2 * a),
               (-b + sqrt(delta)) / (2 * a));
    return 0;
}
/*
Input
1 1 8
Output
NO SOLUTION


Input
1 -2 1
Output
1.00

Input
1 -7 10
Output
2.00 5.00

*/


======================================== ./tuan3/b4(k_Subsequence_even).c ========================================

#include <stdio.h>
int arr[100001];
int main() {
    int n, k;
    scanf("%d %d", &n, &k);
    int i, j;
    for (i = 0; i < n; i++)
        scanf("%d", &arr[i]);
    int sum = 0, dem = 0;
    for (i = 0; i <= n - k; i++) {
        for (j = 0; j < k; j++) {
            sum += arr[i + j];
        }
        if (sum % 2 == 0)
            dem++;
        sum = 0;
    }
    printf("%d", dem);
    return 0;
}
/*
Input
6  3
2 4 5 1 1 2
Output
2
*/


======================================== ./tuan3/b5(Find_all_perfect_square_in_a_sequence).c ========================================

#include <math.h>
#include <stdio.h>

int arr[1000001];
int main() {
    int n;
    scanf("%d", &n);
    int i, dem = 0;
    for (i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
        if (sqrt(arr[i]) == (int)sqrt(arr[i]))
            dem++;
    }
    printf("%d", dem);
    return 0;
}
/*
Input
5
3 2 4 7 9

Output
2

*/


======================================== ./tuan3/b6(Separate_the_integer_and_decimal_parts_of_a_float).c ========================================

#include <stdio.h>
int main() {
    double a;
    scanf("%lf", &a);
    int b = (int)a;
    if (b > a)
        b -= 1;
    double c = a - b;
    printf("%d %.2f", b, c);
    return 0;
}
/*
Input
2.57902
Output
2 0.58

Input
-4.3456
Output
-5 0.65
*/


======================================== ./tuan3/b7(Convert_a_TEXT_to_Upper-Case).c ========================================

#include <ctype.h>
#include <stdio.h>
#include <string.h>

#define MAX 1000000
int main() {
    char arr[MAX];
    while (fgets(arr, MAX, stdin)) {
        int i;
        int k = 'A' - 'a';
        for (i = 0; i < strlen(arr); i++) {
            if ('a' <= arr[i] && arr[i] <= 'z')
                arr[i] += k;
        }
        printf("%s", arr);
    }
    return 0;
}
/*
Input
The TEXT

Output
The TEXT in which characters are converted into upper-case

Example
Input
Hello John,
How are you?

Bye,

Output
HELLO JOHN,
HOW ARE YOU?

BYE,
*/


======================================== ./tuan3/b8(Basic_queries_on_array).c ========================================

#include <stdio.h>
#include <string.h>

int main() {
    int n;
    scanf("%d", &n);

    int a[10005];
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }

    char ch;
    while ((ch = getchar()) != '*' && ch != EOF)
        ;

    char cmd[50];
    while (1) {
        scanf("%s", cmd);
        if (strcmp(cmd, "***") == 0)
            break;

        if (strcmp(cmd, "find-max") == 0) {
            int max = a[0];
            for (int i = 1; i < n; i++)
                if (a[i] > max)
                    max = a[i];
            printf("%d\n", max);
        }

        else if (strcmp(cmd, "find-min") == 0) {
            int min = a[0];
            for (int i = 1; i < n; i++)
                if (a[i] < min)
                    min = a[i];
            printf("%d\n", min);
        }

        else if (strcmp(cmd, "sum") == 0) {
            int s = 0;
            for (int i = 0; i < n; i++)
                s += a[i];
            printf("%d\n", s);
        }

        else if (strcmp(cmd, "find-max-segment") == 0) {
            int i, j;
            scanf("%d %d", &i, &j);
            i--;
            j--;
            int max = a[i];
            for (int k = i + 1; k <= j; k++)
                if (a[k] > max)
                    max = a[k];
            printf("%d\n", max);
        }
    }

    return 0;
}
/*
Input
5
1 4 3 2 5
*
find-max
find-min
find-max-segment 1 3
find-max-segment 2 5
sum
***

Output
5
1
4
5
15
*/


======================================== ./tuan3/bttuan3_202416969.c ========================================

#include <stdio.h>
#include <stdlib.h>

// Hàm Alloc_Cub(m, r, c)

int ***Alloc_Cub(int m, int r, int c) {
    int i, j;
    int ***a = (int ***)malloc(m * sizeof(int **));
    if (!a)
        return NULL;

    for (i = 0; i < m; i++) {
        a[i] = (int **)malloc(r * sizeof(int *));
        if (!a[i])
            return NULL;
        for (j = 0; j < r; j++) {
            a[i][j] = (int *)calloc(c, sizeof(int));
            if (!a[i][j])
                return NULL;
        }
    }
    return a;
}

// Hàm Free_Cub(...)
void Free_Cub(int ***a, int m, int r) {
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < r; j++)
            free(a[i][j]);
        free(a[i]);
    }
    free(a);
}

//* Hàm Realloc_Cub(...)

void Realloc_Cub(int ****p, int m, int r, int c, int m2, int r2, int c2) {
    int ***old = *p;
    int ***new = Alloc_Cub(m2, r2, c2);
    if (!new)
        return;
    int mm = (m < m2 ? m : m2);
    int rr = (r < r2 ? r : r2);
    int cc = (c < c2 ? c : c2);
    for (int i = 0; i < mm; i++)
        for (int j = 0; j < rr; j++)
            for (int k = 0; k < cc; k++)
                new[i][j][k] = old[i][j][k];

    Free_Cub(old, m, r);
    *p = new;
}

int main() {
    int m = 2, r = 3, c = 4;
    int ***a = Alloc_Cub(m, r, c);
    if (!a)
        return 1;

    // Gán giá trị mẫu
    for (int i = 0; i < m; i++)
        for (int j = 0; j < r; j++)
            for (int k = 0; k < c; k++)
                a[i][j][k] = i + j + k;

    printf(" Trước khi cấp phát lại \n");
    for (int i = 0; i < m; i++) {
        printf("M%d:\n", i);
        for (int j = 0; j < r; j++) {
            for (int k = 0; k < c; k++)
                printf("%3d ", a[i][j][k]);
            printf("\n");
        }
        printf("-----------------\n");
    }

    // Tái cấp phát mảng
    int m2 = 4, r2 = 4, c2 = 4;
    Realloc_Cub(&a, m, r, c, m2, r2, c2);

    printf("\n Sau khi cấp phát lại\n");
    for (int i = 0; i < m2; i++) {
        printf("M%d:\n", i);
        for (int j = 0; j < r2; j++) {
            for (int k = 0; k < c2; k++)
                printf("%3d ", a[i][j][k]);
            printf("\n");
        }
        printf("-----------------\n");
    }

    Free_Cub(a, m2, r2);
    return 0;
}



======================================== ./tuan4/b1(Compute_C_k_n).c ========================================

#include <stdio.h>
long long arr[1000][1000] = {0};
long long Ckn(int k, int n) {
    if (k == 0 || k == n)
        return 1;
    else if (k == 1)
        return n;
    if (arr[k][n] != 0)
        return arr[k][n] % 1000000007;
    arr[k][n] = (Ckn(k - 1, n - 1) + Ckn(k, n - 1)) % 1000000007;
    return arr[k][n];
}
int main() {
    int k, n;
    scanf("%d %d", &k, &n);
    printf("%lld", Ckn(k, n));
    return 0;
}
/*
Input
3  5
Output
10
*/


======================================== ./tuan4/b2(Subset_sum_of_elements_equal_to_B).c ========================================

#include <stdio.h>
int arr[101] = {0};
int a, b;
int dem = 0;
int sum = 0;
int Try(int k) {
    for (int i = 0; i <= 1; i++) {
        if (i == 1)
            sum += arr[k];
        if (sum > b) {
            sum -= arr[k];
            continue;
        }
        if (k == a - 1) {
            if (sum == b)
                dem++;
            if (i == 1)
                sum -= arr[k];
        }

        else {
            Try(k + 1);
            if (i == 1)
                sum -= arr[k];
        }
    }
}
int main() {
    scanf("%d %d", &a, &b);
    for (int i = 0; i < a; i++)
        scanf("%d", &arr[i]);
    Try(0);
    printf("%d", dem);
    return 0;
}
/*
Input
5 6
1 2 3 4 5
Output
3
*/


======================================== ./tuan4/b3(Count_number_of_sudoku_solutions).c ========================================

#include <stdio.h>
int arr[10][10];
int dem = 0;
int Check(int m, int n) {
    for (int i = 0; i < 9; i++) {
        if (arr[m][n] == arr[i][n] && arr[m][n] != 0 && i != m)
            return 0;
    }
    for (int i = 0; i < 9; i++) {
        if (arr[m][n] == arr[m][i] && arr[m][n] != 0 && i != n)
            return 0;
    }
    for (int i = m / 3 * 3; i < m / 3 * 3 + 3; i++) {
        for (int j = n / 3 * 3; j < n / 3 * 3 + 3; j++) {
            if (arr[m][n] == arr[i][j] && arr[m][n] != 0 && (m != i || n != j))
                return 0;
        }
    }
    return 1;
}
void Try(int k1, int k2) {
    if (arr[k1][k2] == 0) {
        for (int i = 1; i <= 9; i++) {
            arr[k1][k2] = i;
            if (Check(k1, k2)) {
                if (k1 == 8 && k2 == 8)
                    dem++;
                else if (k2 == 8)
                    Try(k1 + 1, 0);
                else if (k2 < 8)
                    Try(k1, k2 + 1);
            }
            arr[k1][k2] = 0;
        }
    } else if (arr[k1][k2] != 0) {
        if (Check(k1, k2)) {
            if (k1 == k2 && k1 == 8)
                dem++;
            else if (k2 == 8)
                Try(k1 + 1, 0);
            else if (k2 < 8)
                Try(k1, k2 + 1);
        }
    }
}
int main() {
    for (int i = 0; i < 9; i++) {
        for (int j = 0; j < 9; j++) {
            scanf("%d", &arr[i][j]);
        }
    }
    Try(0, 0);
    printf("%d", dem);
    return 0;
}
/*
Input
0 0 3 4 0 0 0 8 9
0 0 6 7 8 9 0 2 3
0 8 0 0 2 3 4 5 6
0 0 4 0 6 5 0 9 7
0 6 0 0 9 0 0 1 4
0 0 7 2 0 4 3 6 5
0 3 0 6 0 2 0 7 8
0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0
Output
64
*/


======================================== ./tuan4/b4(Permutation_generation).c ========================================

#include <stdio.h>
int n;
int arr[50] = {0};
void solution() {
    int dem = 0;
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
    return;
}
int Check() {
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (arr[i] == arr[j])
                return 0;
        }
    }
    return 1;
}
void Try(int k) {
    for (int i = 1; i <= n; i++) {
        arr[k] = i;
        if (k == n - 1) {
            if (Check()) {
                solution();
            }
        } else
            Try(k + 1);
    }
}

int main() {
    scanf("%d", &n);
    Try(0);
    return 0;
}
/*
Input
3
Output
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1

*/


======================================== ./tuan4/b5(Convert_integer_to_binary_string).c ========================================

#include <stdio.h>
int n;
void Binary(int n) {
    if (n == 0) {
        printf("0");
    } else if (n == 1) {
        printf("1");
    } else {
        Binary(n / 2);
        printf("%d", n % 2);
    }
}

int main() {
    scanf("%d", &n);
    Binary(n);
    return 0;
}
/*
Input
20

Output
10100
*/


======================================== ./tuan4/b6(Binary_sequences_generation_without_consecutive_11).c ========================================

#include <stdio.h>
int n;
int arr[21] = {0};
void solution() {
    for (int i = 0; i < n; i++)
        printf("%d", arr[i]);
    printf("\n");
}
void Try(int k) {
    for (int i = 0; i <= 1; i++) {
        arr[k] = i;
        if (arr[k] == 1 && arr[k - 1] == 1)
            continue;
        if (k == n - 1)
            solution();
        else
            Try(k + 1);
    }
}
int main() {
    scanf("%d", &n);
    Try(0);
    return 0;
}
/*
Input
3
Output
000
001
010
100
101
*/


======================================== ./tuan4/b7(Linear_Integer_Equation_coefficent_1).c ========================================

#include <stdio.h>
int n, m;
int arr[11];
int sum = 0;
void solution() {
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\n");
}
void Try(int k) {
    for (int i = 1; i <= m - n + 1; i++) {
        arr[k] = i;
        sum += i;
        if (k == n - 1) {
            if (sum == m)
                solution();
        } else
            Try(k + 1);
        sum -= i;
    }
}
int main() {
    scanf("%d %d", &n, &m);
    Try(0);
    return 0;
}
/*
Input
3  5
Output
1 1 3
1 2 2
1 3 1
2 1 2
2 2 1
3 1 1
*/


======================================== ./tuan4/b8(Count_number_of_Queen_solutions_with_some_specified_queens).c ========================================

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

int arr[13][13] = {0};
int n;
int dem = 0;
int Check(int r, int c) {
    for (int i = 0; i < n; i++) {
        if (i != c && arr[r][i] == 1)
            return 0;
    }
    for (int i = 0; i < n; i++) {
        if (i != r && arr[i][c] == 1)
            return 0;
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (arr[i][j] == 1) {
                if (i == r && j == c)
                    continue;
                if (abs(i - r) == abs(j - c))
                    return 0;
            }
        }
    }

    return 1;
}

/* backtracking by row: place exactly one queen per row (unless a preset queen
 * exists in that row) */
void TryRow(int r) {
    if (r == n) {
        dem++;
        return;
    }

    /* if this row already has a preset queen, skip to next row */
    int preset_col = -1;
    for (int j = 0; j < n; ++j) {
        if (arr[r][j] == 1) {
            preset_col = j;
            break;
        }
    }
    if (preset_col != -1) {
        /* only proceed if the preset queen is not in conflict (presets will be
           validated in main)
           but Check may still be used to ensure no conflict with queens placed
           in previous rows */
        if (Check(r, preset_col))
            TryRow(r + 1);
        return;
    }

    /* try placing a queen in each column of this row */
    for (int j = 0; j < n; ++j) {
        if (Check(r, j)) {
            arr[r][j] = 1;
            TryRow(r + 1);
            arr[r][j] = 0;
        }
    }
}
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &arr[i][j]);
        }
    }
    /* validate preset queens don't attack each other */
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (arr[i][j] == 1) {
                if (!Check(i, j)) {
                    printf("0");
                    return 0;
                }
            }
        }
    }

    TryRow(0);
    printf("%d", dem);
    return 0;
}
/*
Input
4
0 1 0 0
0 0 0 0
0 0 0 0
0 0 1 0
Output
1


Input
5
0 1 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
0 0 0 0 0
Output
2
*/



======================================== ./tuan5/b1(Hanoi_Tower).c ========================================

#include <stdio.h>
int n, A, B, C, D;
int dem = 0;
int Hanoi(int n, int A, int B, int C, int D) {
    dem++;
    if (n == 1) {
        if (D != 0)
            printf("%d %d\n", A, B);
        return dem;
    }
    Hanoi(n - 1, A, C, B, D);
    if (D != 0)
        printf("%d %d\n", A, B);
    Hanoi(n - 1, C, B, A, D);
}

int main() {
    scanf("%d %d %d %d", &n, &A, &B, &C);
    Hanoi(n, A, B, C, 0);
    printf("%d\n", dem);
    dem = 0;
    Hanoi(n, A, B, C, 1);
    return 0;
}
/*
Input
2 10 20 30

Output
3
10 30
10 20
30 20
*/


======================================== ./tuan5/b2(Count_Solutions_TSP).c ========================================

#include <limits.h>
#include <stdio.h>

int n, maxdis;
int arr[101][101];
int dis = 0;
int dem = 0;
int C[101]; // tp di qua
int visited[101] = {0};
void Try(int i) {
    for (int j = 1; j < n; j++) {
        if (visited[j] == 0) {
            visited[j] = 1;
            C[i] = j;
            dis += arr[C[i - 1]][C[i]];
            if (i < n - 1)
                Try(i + 1);
            else if (i == n - 1) {
                if (maxdis - dis - arr[C[n - 1]][C[0]] >= 0)
                    dem++;
            }
        } else
            continue;
        visited[j] = 0;
        dis -= arr[C[i - 1]][C[i]];
    }
}
int main() {
    scanf("%d %d", &n, &maxdis);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &arr[i][j]);
        }
    }
    visited[0] = 1;
    Try(1);
    printf("%d", dem);
    return 0;
}
/*
Input
4  10
0 1 2 6
1 0 5 4
2 5 0 3
6 4 3 0
Output
2
*/


======================================== ./tuan5/b3(Binary_sequence_generation).c ========================================

#include <stdio.h>

int n;
int a[25];

void print() {
    for (int i = 0; i < n; i++)
        printf("%d", a[i]);
    printf("\n");
}

void Try(int k) {
    for (int v = 0; v <= 1; v++) {
        a[k] = v;
        if (k == n - 1)
            print();
        else
            Try(k + 1);
    }
}

int main() {
    scanf("%d", &n);
    Try(0);
    return 0;
}
/*
Input
3
Output
000
001
010
011
100
101
110
111
*/


======================================== ./tuan5/b4(Fibonacci).c ========================================

#include <stdio.h>
int n, arr[100002] = {0};
long long Fun(int n) {
    if (n == 0)
        return 0;
    else if (n == 1)
        return 1;
    else if (n >= 2) {
        if (arr[n] != 0)
            return arr[n];
        else {
            arr[n] = (Fun(n - 1) + Fun(n - 2)) % 1000000007;
            return arr[n];
        }
    }
}
int main() {
    scanf("%d", &n);
    printf("%d", Fun(n));
    return 0;
}
/*
Input
4
Output
3
*/


======================================== ./tuan5/b5(Greatest_Common_Divisor).c ========================================

#include <stdio.h>
int GCD(int a, int b) {
    if (a % b == 0)
        return b;
    a = a % b;
    return GCD(b, a);
}
int main() {
    int a, b;
    scanf("%d %d", &a, &b);
    printf("%d", GCD(a, b));
    return 0;
}
/*
Input
16 24

Output
8
*/


======================================== ./tuan5/b6(TSP).c ========================================

#include <limits.h>
#include <stdio.h>

int mindis = INT_MAX;
int n, dis = 0;
int arrdis[105][105];
int last[105];
int visited[105] = {0};
void Try(int i) {
    for (int j = 1; j < n; j++) {
        if (visited[j] == 0) {
            visited[j] = 1;
            last[i] = j;
            dis += arrdis[last[i - 1]][last[i]];
            if (dis > mindis) {
                visited[j] = 0;
                dis -= arrdis[last[i - 1]][last[i]];
                continue;
            }
            if (i < n - 1)
                Try(i + 1);
            else if (i == n - 1) {
                if (mindis > dis + arrdis[last[n - 1]][last[0]])
                    mindis = dis + arrdis[last[n - 1]][last[0]];
            }
        } else
            continue;
        visited[j] = 0;
        dis -= arrdis[last[i - 1]][last[i]];
    }
}
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &arrdis[i][j]);
        }
    }
    visited[0] = 1;
    Try(1);
    printf("%d", mindis);
    return 0;
}
/*
Input
4
0 1 1 9
1 0 9 3
1 9 0 2
9 3 2 0
Output
7
*/


======================================== ./tuan6/b1(WATER_JUGS).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 901

typedef struct {
    int a, b, steps;
} State;

int visited[MAX][MAX];

int gcd(int x, int y) {
    return y == 0 ? x : gcd(y, x % y);
}

int minSteps(int a, int b, int c) {
    if (c > a && c > b)
        return -1;
    if (c % gcd(a, b) != 0)
        return -1;

    memset(visited, 0, sizeof(visited));
    State queue[MAX * MAX];
    int front = 0, rear = 0;

    queue[rear++] = (State){0, 0, 0};

    while (front < rear) {
        State curr = queue[front++];
        int x = curr.a, y = curr.b;

        if (x == c || y == c)
            return curr.steps;
        if (visited[x][y])
            continue;
        visited[x][y] = 1;

        queue[rear++] = (State){a, y, curr.steps + 1};
        queue[rear++] = (State){x, b, curr.steps + 1};
        queue[rear++] = (State){0, y, curr.steps + 1};
        queue[rear++] = (State){x, 0, curr.steps + 1};
        int pour = (x < b - y) ? x : (b - y);
        queue[rear++] = (State){x - pour, y + pour, curr.steps + 1};
        pour = (y < a - x) ? y : (a - x);
        queue[rear++] = (State){x + pour, y - pour, curr.steps + 1};
    }

    return -1;
}

int main() {
    int a, b, c;
    scanf("%d %d %d", &a, &b, &c);
    printf("%d\n", minSteps(a, b, c));
    return 0;
}
/*
Input
6  8  4
Output
4
*/


======================================== ./tuan6/b2(Simulation_Stack).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define MAX 1000

int stack[MAX];
int top = -1;

void push(int v) {
    if (top < MAX - 1) {
        stack[++top] = v;
    }
}

void pop() {
    if (top >= 0) {
        printf("%d\n", stack[top--]);
    } else {
        printf("NULL\n");
    }
}

int main() {
    char line[100];
    while (fgets(line, sizeof(line), stdin)) {
        if (line[0] == '#')
            break;

        if (strncmp(line, "PUSH", 4) == 0) {
            int v;
            sscanf(line + 5, "%d", &v);
            push(v);
        } else if (strncmp(line, "POP", 3) == 0) {
            pop();
        }
    }
    return 0;
}
/*
Input
PUSH 1
PUSH 2
PUSH 3
POP
POP
PUSH 4
PUSH 5
POP
#
Output
3
2
5
*/


======================================== ./tuan6/b3(Simulation_Queue).c ========================================

// Perform a sequence of operations over a queue, each element is an integer:
// PUSH v: push a value v into the queue
// POP: remove an element out of the queue and print this element to stdout
// (print NULL if the queue is empty) Input Each line contains a command
// (operration) of type PUSH  v POP Output Write the results of POP operations
// (each result is written in a line)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 1000

int queue[MAX];
int front = 0, rear = 0;

void push(int v) {
    if (rear < MAX) {
        queue[rear++] = v;
    }
}

void pop() {
    if (front < rear) {
        printf("%d\n", queue[front++]);
    } else {
        printf("NULL\n");
    }
}

int main() {
    char line[100];
    while (fgets(line, sizeof(line), stdin)) {
        if (line[0] == '#')
            break;

        if (strncmp(line, "PUSH", 4) == 0) {
            int v;
            sscanf(line + 5, "%d", &v);
            push(v);
        } else if (strncmp(line, "POP", 3) == 0) {
            pop();
        }
    }
    return 0;
}
/*
Input
PUSH 1
PUSH 2
PUSH 3
POP
POP
PUSH 4
PUSH 5
POP
#
Output
1
2
3

Input
PUSH 1
POP
POP
PUSH 4
POP
#
Output
1
NULL
4
*/


======================================== ./tuan6/b4(Polynomial_Manipulation).c ========================================

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Node
typedef struct TERM {
    int coef;
    int exp;
    struct TERM *next;

} term;
// head
term *polys[10001] = {NULL};
//
void create(int id) {
    if (polys[id] == NULL)
        polys[id] = NULL;
}
// addterm exp so mu theo thu tu
void addterm(int id, int coef, int exp) {
    if (!coef)
        return;
    create(id);
    term *cur = polys[id], *prev = NULL;
    while (cur && cur->exp > exp) {
        prev = cur;
        cur = cur->next;
    }
    // có sẵn exp
    if (cur && cur->exp == exp) {
        cur->coef += coef;
        // coef = 0
        if (cur->coef == 0) {
            if (prev)
                prev->next = cur->next;
            else
                polys[id] = cur->next;
            free(cur);
        }
    }
    // chưa có exp
    else {
        term *newterm = (term *)malloc(sizeof(term));
        newterm->coef = coef;
        newterm->exp = exp;
        newterm->next = cur;
        if (prev)
            prev->next = newterm;
        else
            polys[id] = newterm;
    }
}
// tính ,in
void evaluatepoly(int id, int x) {
    int sum = 0;
    term *cur = polys[id];
    if (!cur) {
        printf("0\n");
        return;
    } else {
        while (cur) {
            sum += (cur->coef) * (int)pow(x, cur->exp);
            cur = cur->next;
        }
    }
    printf("%d\n", sum);
}
// destroy
void destroy(int id) {
    term *cur = polys[id];
    while (cur) {
        term *temp = cur;
        cur = cur->next;
        free(temp);
    }
    polys[id] = NULL;
}
// add poly cộng hàm đa thức
void addpoly(int id1, int id2, int result_id) {
    term *cur1 = polys[id1], *cur2 = polys[id2];
    if (cur1 == NULL && cur2 == NULL)
        return;
    destroy(result_id);
    polys[result_id] = NULL;
    while (cur1 && cur2) {
        // addterm(int id, int coef, int exp)
        if (cur1->exp == cur2->exp) {
            addterm(result_id, cur1->coef + cur2->coef, cur1->exp);
            cur1 = cur1->next;
            cur2 = cur2->next;
        } else if (cur1->exp > cur2->exp) {
            addterm(result_id, cur1->coef, cur1->exp);
            cur1 = cur1->next;

        } else if (cur2->exp > cur1->exp) {
            addterm(result_id, cur2->coef, cur2->exp);
            cur2 = cur2->next;
        }
    }
    while (cur1) {
        addterm(result_id, cur1->coef, cur1->exp);
        cur1 = cur1->next;
    }
    while (cur2) {
        addterm(result_id, cur2->coef, cur2->exp);
        cur2 = cur2->next;
    }
}
// print poly
void printpoly(int id) {
    if (!polys[id])
        return;
    term *cur = polys[id];
    while (cur) {
        printf("%d %d", cur->coef, cur->exp);
        cur = cur->next;
        if (cur)
            printf(" ");
    }
    printf("\n");
}
int main() {
    char line[50];
    while (fgets(line, sizeof(line), stdin)) {
        if (line[0] == '*')
            return 0;
        if (!strncmp(line, "Create", 6)) {
            int v;
            sscanf(line + 7, "%d", &v);
            create(v);
        } else if (!strncmp(line, "AddTerm", 7)) {
            int id, coef, exp;
            sscanf(line + 8, "%d %d %d", &id, &coef, &exp);
            addterm(id, coef, exp);
        } else if (!strncmp(line, "Destroy", 7)) {
            int id;
            sscanf(line + 8, "%d", &id);
            destroy(id);
        } else if (!strncmp(line, "AddPoly", 7)) {
            int id1, id2, result_id;
            sscanf(line + 8, "%d %d %d", &id1, &id2, &result_id);
            addpoly(id1, id2, result_id);
        } else if (!strncmp(line, "PrintPoly", 9)) {
            int id;
            sscanf(line + 10, "%d", &id);
            printpoly(id);
        } else if (!strncmp(line, "EvaluatePoly", 12)) {
            int id, x;
            sscanf(line + 13, "%d %d", &id, &x);
            evaluatepoly(id, x);
        }
    }
    return 0;
}
/*
Example
Input
AddTerm 1 3 2
AddTerm 1 4 0
AddTerm 1 6 2
AddTerm 2 3 2
AddTerm 2 7 5
PrintPoly 1
PrintPoly 2
AddPoly 2 1 3
PrintPoly 3
EvaluatePoly 2 1
*

Output
9 2 4 0
7 5 3 2
7 5 12 2 4 0
10
*/


======================================== ./tuan6/b5(Parenthesis).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX 1000005

char stack[MAX];
int top = -1;

int isMatching(char open, char close) {
    return (open == '(' && close == ')') || (open == '[' && close == ']') ||
           (open == '{' && close == '}');
}

int isBalanced(const char *str) {
    for (int i = 0; str[i]; i++) {
        char ch = str[i];
        if (ch == '(' || ch == '[' || ch == '{') {
            stack[++top] = ch;
        } else if (ch == ')' || ch == ']' || ch == '}') {
            if (top == -1 || !isMatching(stack[top], ch)) {
                return 0;
            }
            top--;
        }
    }
    return top == -1;
}

int main() {
    char str[MAX];
    if (scanf("%s", str) == 1) {
        printf("%d\n", isBalanced(str));
    }
    return 0;
}
/*
input
(()[][]{}){}{}[][]({[]()})
output
1
*/


======================================== ./tuan6/b6(Maze).c ========================================

#include <stdio.h>
#define max 1000
int maze[max][max];
int n, m, r, c;
int visited[max][max] = {0};
// isBorder
int isBorder(int x, int y) {
    return x == 0 || y == 0 || x == n - 1 || y == m - 1;
}
// bfs
typedef struct {
    int x;
    int y;
    int step;
} node;
node queue[max * max];
int front = 0, rear = 0;
int dx[] = {0, 0, 1, -1}; // xuống , lên , phải , trái
int dy[] = {1, -1, 0, 0};
int bfs(int start_x, int start_y) {
    front = 0, rear = 0;
    queue[rear++] = (node){start_x, start_y, 0};
    visited[start_x][start_y] = 1;
    while (front < rear) {
        node curr = queue[front++];
        if (isBorder(curr.x, curr.y))
            return curr.step;
        for (int i = 0; i < 4; i++) {
            int nx = curr.x + dx[i];
            int ny = curr.y + dy[i];
            if (nx >= 0 && nx < n && ny >= 0 && ny < m && !visited[nx][ny] &&
                maze[nx][ny] == 0) {
                visited[nx][ny] = 1;
                queue[rear++] = (node){nx, ny, curr.step + 1};
            }
        }
    }

    return -1;
}
// Ghi giá số bước cần di chuyển ngắn nhất để thoát ra khỏi mê cung,
// hoặc ghi giá trị -1 nếu không tìm thấy đường đi nào thoát ra khỏi mê cung.
int main() {
    // freopen("input.txt", "r", stdin);
    // freopen("output.txt", "w", stdout);
    //
    scanf("%d %d %d %d", &n, &m, &r, &c);
    r--, c--;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            scanf("%d", &maze[i][j]);
        }
    }
    int result = bfs(r, c);
    printf("%d", result == -1 ? result : result + 1);
    return 0;
}
/*
Input
8 12 5 6
1 1 0 0 0 0 1 0 0 0 0 1
1 0 0 0 1 1 0 1 0 0 1 1
0 0 1 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 1 0 0 1 0 1
1 0 0 1 0 0 0 0 0 1 0 0
1 0 1 0 1 0 0 0 1 0 1 0
0 0 0 0 1 0 1 0 0 0 0 0
1 0 1 1 0 1 1 1 0 1 0 1

Output
7
*/


======================================== ./tuan6/b7(Linked_List_Manipulation).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int key;
    struct Node *next;
} Node;

Node *head = NULL;

// Kiểm tra xem một giá trị đã tồn tại trong danh sách chưa
int exists(int key) {
    Node *p = head;
    while (p) {
        if (p->key == key)
            return 1;
        p = p->next;
    }
    return 0;
}

// Thêm vào đầu danh sách
void addFirst(int key) {
    if (exists(key))
        return;
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->key = key;
    newNode->next = head;
    head = newNode;
}

// Thêm vào cuối danh sách
void addLast(int key) {
    if (exists(key))
        return;
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->key = key;
    newNode->next = NULL;
    if (!head) {
        head = newNode;
        return;
    }
    Node *p = head;
    while (p->next)
        p = p->next;
    p->next = newNode;
}

// Thêm sau phần tử có key = afterKey
void addAfter(int key, int afterKey) {
    if (exists(key))
        return;
    Node *p = head;
    while (p && p->key != afterKey)
        p = p->next;
    if (!p)
        return;
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->key = key;
    newNode->next = p->next;
    p->next = newNode;
}

// Thêm trước phần tử có key = beforeKey
void addBefore(int key, int beforeKey) {
    if (exists(key))
        return;
    if (!head)
        return;
    if (head->key == beforeKey) {
        addFirst(key);
        return;
    }
    Node *prev = NULL;
    Node *curr = head;
    while (curr && curr->key != beforeKey) {
        prev = curr;
        curr = curr->next;
    }
    if (!curr)
        return;
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->key = key;
    newNode->next = curr;
    prev->next = newNode;
}

// Xóa phần tử có key = key
void removeKey(int key) {
    if (!head)
        return;
    if (head->key == key) {
        Node *tmp = head;
        head = head->next;
        free(tmp);
        return;
    }
    Node *prev = NULL;
    Node *curr = head;
    while (curr && curr->key != key) {
        prev = curr;
        curr = curr->next;
    }
    if (!curr)
        return;
    prev->next = curr->next;
    free(curr);
}

// Đảo ngược danh sách
void reverse() {
    Node *prev = NULL;
    Node *curr = head;
    while (curr) {
        Node *next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    head = prev;
}

// In danh sách
void printList() {
    Node *p = head;
    while (p) {
        printf("%d", p->key);
        if (p->next)
            printf(" ");
        p = p->next;
    }
    printf("\n");
}

int main() {
    int n, x;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &x);
        addLast(x);
    }

    char cmd[50];
    while (scanf("%s", cmd) && strcmp(cmd, "#") != 0) {
        if (strcmp(cmd, "addlast") == 0) {
            int k;
            scanf("%d", &k);
            addLast(k);
        } else if (strcmp(cmd, "addfirst") == 0) {
            int k;
            scanf("%d", &k);
            addFirst(k);
        } else if (strcmp(cmd, "addafter") == 0) {
            int u, v;
            scanf("%d %d", &u, &v);
            addAfter(u, v);
        } else if (strcmp(cmd, "addbefore") == 0) {
            int u, v;
            scanf("%d %d", &u, &v);
            addBefore(u, v);
        } else if (strcmp(cmd, "remove") == 0) {
            int k;
            scanf("%d", &k);
            removeKey(k);
        } else if (strcmp(cmd, "reverse") == 0) {
            reverse();
        }
    }

    printList();
    return 0;
}
/*
Input
5
5 4 3 2 1
addlast 3
addlast 10
addfirst 1
addafter 10 4
remove 1
#

Output
5 4 3 2 10
*/


======================================== ./tuan6/b8(Delete_number).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define max 120000
char stack[120002];
int top = 0;
// stack
void push(char num) {
    if (top < max) {
        stack[top++] = num;
    }
    return;
}
void pop() {
    if (top > 0) {
        top--;
    }
    return;
}
//
int main() {
    char line[120002];
    fgets(line, sizeof(line), stdin);
    int len = strlen(line);
    if (line[len - 1] == '\n')
        len--;
    int k;
    scanf("%d", &k);

    for (int j = 0; j < len; j++) {
        while (k > 0 && top > 0 && stack[top - 1] > line[j]) {
            pop();
            k--;
        }
        push(line[j]);
    }
    while (k > 0 && top > 0) {
        pop();
        k--;
    }
    for (int i = 0; i < top; i++) {
        printf("%c", stack[i]);
    }
    return 0;
}
/*
Input:
869357495356872
9
Output:
335672
*/


======================================== ./tuan7/b1(Binary_Tree_Manipulation_&_Traversal).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int id;
    struct Node *left, *right;
} Node;

Node *root = NULL;
Node *find(Node *r, int id) {
    if (r == NULL)
        return NULL;
    if (r->id == id)
        return r;
    Node *left = find(r->left, id);
    if (left)
        return left;
    return find(r->right, id);
}
Node *newNode(int id) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->id = id;
    p->left = p->right = NULL;
    return p;
}
void preOrder(Node *r) {
    if (r == NULL)
        return;
    printf("%d ", r->id);
    preOrder(r->left);
    preOrder(r->right);
}
void inOrder(Node *r) {
    if (r == NULL)
        return;
    inOrder(r->left);
    printf("%d ", r->id);
    inOrder(r->right);
}
void postOrder(Node *r) {
    if (r == NULL)
        return;
    postOrder(r->left);
    postOrder(r->right);
    printf("%d ", r->id);
}

int main() {
    char cmd[20];
    int u, v;

    while (1) {
        scanf("%s", cmd);
        if (cmd[0] == '*')
            break;

        if (strcmp(cmd, "MakeRoot") == 0) {
            scanf("%d", &u);
            root = newNode(u);
        } else if (strcmp(cmd, "AddLeft") == 0) {
            scanf("%d %d", &u, &v);
            if (find(root, u) != NULL)
                continue;
            Node *parent = find(root, v);
            if (parent == NULL)
                continue;
            if (parent->left != NULL)
                continue;
            parent->left = newNode(u);
        } else if (strcmp(cmd, "AddRight") == 0) {
            scanf("%d %d", &u, &v);
            if (find(root, u) != NULL)
                continue;
            Node *parent = find(root, v);
            if (parent == NULL)
                continue;
            if (parent->right != NULL)
                continue;
            parent->right = newNode(u);
        } else if (strcmp(cmd, "PreOrder") == 0) {
            preOrder(root);
            printf("\n");
        } else if (strcmp(cmd, "InOrder") == 0) {
            inOrder(root);
            printf("\n");
        } else if (strcmp(cmd, "PostOrder") == 0) {
            postOrder(root);
            printf("\n");
        }
    }

    return 0;
}
/*
Input
MakeRoot 1
AddLeft 2 1
AddRight 3 1
AddLeft 4 3
AddRight 5 2
PreOrder
AddLeft 6 5
AddRight 7 5
InOrder
*

Output
1 2 5 3 4
2 6 5 7 1 4 3
*/


======================================== ./tuan7/b2(Binary_tree_path_sum).c ========================================

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct Node {
    int id;
    struct Node *left, *right;
} Node;

#define MAXN 10005
Node *nodes[MAXN];

Node *createNode(int id) {
    Node *node = (Node *)malloc(sizeof(Node));
    node->id = id;
    node->left = node->right = NULL;
    return node;
}

bool hasPathSum(Node *root, int targetSum, int currentSum) {
    if (!root)
        return false;
    currentSum += root->id;

    if (!root->left && !root->right) {
        return currentSum == targetSum;
    }

    return hasPathSum(root->left, targetSum, currentSum) ||
           hasPathSum(root->right, targetSum, currentSum);
}

int main() {
    char cmd[20];
    int u, v;
    Node *root = NULL;

    for (int i = 0; i < MAXN; i++)
        nodes[i] = NULL;

    while (scanf("%s", cmd)) {
        if (strcmp(cmd, "*") == 0)
            break;

        if (strcmp(cmd, "MakeRoot") == 0) {
            scanf("%d", &u);
            if (!nodes[u]) {
                nodes[u] = createNode(u);
            }
            root = nodes[u];
        } else if (strcmp(cmd, "AddLeft") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v] && nodes[v]->left == NULL) {
                nodes[u] = createNode(u);
                nodes[v]->left = nodes[u];
            }
        } else if (strcmp(cmd, "AddRight") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v] && nodes[v]->right == NULL) {
                nodes[u] = createNode(u);
                nodes[v]->right = nodes[u];
            }
        } else if (strcmp(cmd, "PathSum") == 0) {
            scanf("%d", &u);
            if (root && hasPathSum(root, u, 0)) {
                printf("True\n");
            } else {
                printf("False\n");
            }
        }
    }

    return 0;
}
/*
Example:
MakeRoot 1
AddLeft 2 1
AddRight 3 1
AddLeft 4 3
AddRight 5 2
AddLeft 6 5
AddRight 7 5
PathSum 4
PathSum 5
PathSum 8
PathSum 14
PathSum 15
PathSum 20
*
Output:
False
False
True
True
True
False
*/


======================================== ./tuan7/b3(Family_Tree).c ========================================

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    char name[50];
    struct Node *children[100];
    int childCount;
} Node;

#define MAXN 10005
Node *nodes[MAXN];
int nodeCount = 0;
Node *getNode(char *name) {
    for (int i = 0; i < nodeCount; i++) {
        if (strcmp(nodes[i]->name, name) == 0)
            return nodes[i];
    }
    Node *newNode = (Node *)malloc(sizeof(Node));
    strcpy(newNode->name, name);
    newNode->childCount = 0;
    nodes[nodeCount++] = newNode;
    return newNode;
}
int countDescendants(Node *root) {
    if (!root)
        return 0;
    int total = root->childCount;
    for (int i = 0; i < root->childCount; i++) {
        total += countDescendants(root->children[i]);
    }
    return total;
}
int countGenerations(Node *root) {
    if (!root || root->childCount == 0)
        return 0;
    int maxGen = 0;
    for (int i = 0; i < root->childCount; i++) {
        int g = countGenerations(root->children[i]);
        if (g > maxGen)
            maxGen = g;
    }
    return 1 + maxGen;
}

int main() {
    char child[50], parent[50];
    char cmd[20], param[50];
    while (scanf("%s", child)) {
        if (strcmp(child, "***") == 0)
            break;
        scanf("%s", parent);
        Node *cNode = getNode(child);
        Node *pNode = getNode(parent);
        pNode->children[pNode->childCount++] = cNode;
    }
    while (scanf("%s", cmd)) {
        if (strcmp(cmd, "***") == 0)
            break;
        scanf("%s", param);
        Node *node = getNode(param);

        if (strcmp(cmd, "descendants") == 0) {
            printf("%d\n", countDescendants(node));
        } else if (strcmp(cmd, "generation") == 0) {
            printf("%d\n", countGenerations(node));
        }
    }

    return 0;
}
/*
Output
Each line is the result of a corresponding query.
Example
Input
Peter Newman
Michael Thomas
John David
Paul Mark
Stephan Mark
Pierre Thomas
Mark Newman
Bill David
David Newman
Thomas Mark
***
descendants Newman
descendants Mark
descendants David
generation Mark
***
Output
10
5
2
2
*/


======================================== ./tuan7/b4(Check_balanced_binary_tree_and_compute_the_height).c ========================================

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct Node {
    int id;
    struct Node *left, *right;
} Node;

#define MAXN 50005
Node *nodes[MAXN];
Node *root = NULL;

Node *getNode(int id) {
    if (nodes[id] == NULL) {
        nodes[id] = (Node *)malloc(sizeof(Node));
        nodes[id]->id = id;
        nodes[id]->left = nodes[id]->right = NULL;
    }
    return nodes[id];
}

int checkHeight(Node *node, bool *balanced) {
    if (!node)
        return 0;
    int lh = checkHeight(node->left, balanced);
    int rh = checkHeight(node->right, balanced);
    if (abs(lh - rh) > 1)
        *balanced = false;
    return (lh > rh ? lh : rh) + 1;
}

int main() {
    char cmd[20];
    int u, v;
    for (int i = 0; i < MAXN; i++)
        nodes[i] = NULL;

    while (scanf("%s", cmd)) {
        if (strcmp(cmd, "*") == 0)
            break;

        if (strcmp(cmd, "MakeRoot") == 0) {
            scanf("%d", &u);
            root = getNode(u);
        } else if (strcmp(cmd, "AddLeft") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v] && nodes[v]->left == NULL) {
                nodes[u] = getNode(u);
                nodes[v]->left = nodes[u];
            }
        } else if (strcmp(cmd, "AddRight") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v] && nodes[v]->right == NULL) {
                nodes[u] = getNode(u);
                nodes[v]->right = nodes[u];
            }
        }
    }

    bool balanced = true;
    int height = checkHeight(root, &balanced);

    printf("%d %d\n", balanced ? 1 : 0, height);

    return 0;
}
/*
Example
Input
MakeRoot 1
AddLeft 2 1
AddRight 3 1
AddLeft 9 2
AddRight 4 2
AddLeft 6 3
AddRight 5 3
AddLeft 7 4
AddRight 8 4
*
Output
1 4
*/


======================================== ./tuan7/b5(Tree_manipulation_&_Traversal).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int id;
    struct Node *children[100];
    int childCount;
} Node;

#define MAXN 10005
Node *nodes[MAXN];
Node *root = NULL;
Node *getNode(int id) {
    if (nodes[id] == NULL) {
        nodes[id] = (Node *)malloc(sizeof(Node));
        nodes[id]->id = id;
        nodes[id]->childCount = 0;
    }
    return nodes[id];
}

// Duyệt PreOrder
void preorder(Node *node) {
    if (!node)
        return;
    printf("%d ", node->id);
    for (int i = 0; i < node->childCount; i++) {
        preorder(node->children[i]);
    }
}

void inorder(Node *node) {
    if (!node)
        return;
    int mid = node->childCount / 2;
    for (int i = 0; i < mid; i++) {
        inorder(node->children[i]);
    }
    printf("%d ", node->id);
    for (int i = mid; i < node->childCount; i++) {
        inorder(node->children[i]);
    }
}

void postorder(Node *node) {
    if (!node)
        return;
    for (int i = 0; i < node->childCount; i++) {
        postorder(node->children[i]);
    }
    printf("%d ", node->id);
}

int main() {
    char cmd[20];
    int u, v;

    for (int i = 0; i < MAXN; i++)
        nodes[i] = NULL;

    while (scanf("%s", cmd)) {
        if (strcmp(cmd, "*") == 0)
            break;

        if (strcmp(cmd, "MakeRoot") == 0) {
            scanf("%d", &u);
            root = getNode(u);
        } else if (strcmp(cmd, "Insert") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v]) {
                Node *child = getNode(u);
                Node *parent = nodes[v];
                parent->children[parent->childCount++] = child;
            }
        } else if (strcmp(cmd, "PreOrder") == 0) {
            preorder(root);
            printf("\n");
        } else if (strcmp(cmd, "InOrder") == 0) {
            inorder(root);
            printf("\n");
        } else if (strcmp(cmd, "PostOrder") == 0) {
            postorder(root);
            printf("\n");
        }
    }

    return 0;
}
/*
Dữ liệu
MakeRoot 10
Insert 11 10
Insert 1 10
Insert 3 10
InOrder
Insert 5 11
Insert 4 11
Insert 8 3
PreOrder
Insert 2 3
Insert 7 3
Insert 6 4
Insert 9 4
InOrder
PostOrder
*
Kết quả
11 10 1 3
10 11 5 4 1 3 8
5 11 6 4 9 10 1 8 3 2 7
5 6 9 4 11 1 8 2 7 3 10
*/


======================================== ./tuan7/b6(Tree_manipulation_and_traversal).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int id;
    struct Node *children[100]; // danh sách con
    int childCount;
} Node;

#define MAXN 50005
Node *nodes[MAXN];
Node *root = NULL;

// Tạo hoặc lấy node theo id
Node *getNode(int id) {
    if (nodes[id] == NULL) {
        nodes[id] = (Node *)malloc(sizeof(Node));
        nodes[id]->id = id;
        nodes[id]->childCount = 0;
    }
    return nodes[id];
}

// Duyệt PreOrder: thăm node trước, rồi duyệt các con
void preorder(Node *node) {
    if (!node)
        return;
    printf("%d ", node->id);
    for (int i = 0; i < node->childCount; i++) {
        preorder(node->children[i]);
    }
}

// Duyệt InOrder: nếu có 1 con → duyệt con rồi node; nếu nhiều con → nửa đầu,
// node, nửa sau
void inorder(Node *node) {
    if (!node)
        return;

    if (node->childCount == 1) {
        inorder(node->children[0]);
        printf("%d ", node->id);
    } else {
        int mid = node->childCount / 2;
        for (int i = 0; i < mid; i++) {
            inorder(node->children[i]);
        }
        printf("%d ", node->id);
        for (int i = mid; i < node->childCount; i++) {
            inorder(node->children[i]);
        }
    }
}

// Duyệt PostOrder: duyệt các con trước, rồi thăm node
void postorder(Node *node) {
    if (!node)
        return;
    for (int i = 0; i < node->childCount; i++) {
        postorder(node->children[i]);
    }
    printf("%d ", node->id);
}

int main() {
    char cmd[20];
    int u, v;

    for (int i = 0; i < MAXN; i++)
        nodes[i] = NULL;

    while (scanf("%s", cmd)) {
        if (strcmp(cmd, "*") == 0)
            break;

        if (strcmp(cmd, "MakeRoot") == 0) {
            scanf("%d", &u);
            root = getNode(u);
        } else if (strcmp(cmd, "Insert") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v]) {
                Node *child = getNode(u);
                Node *parent = nodes[v];
                parent->children[parent->childCount++] = child;
            }
        } else if (strcmp(cmd, "PreOrder") == 0) {
            preorder(root);
            printf("\n");
        } else if (strcmp(cmd, "InOrder") == 0) {
            inorder(root);
            printf("\n");
        } else if (strcmp(cmd, "PostOrder") == 0) {
            postorder(root);
            printf("\n");
        }
    }

    return 0;
}
/*
Dữ liệu
MakeRoot 10
Insert 11 10
Insert 1 10
Insert 3 10
InOrder
Insert 5 11
Insert 4 11
Insert 8 3
PreOrder
Insert 2 3
Insert 7 3
Insert 6 4
Insert 9 4
InOrder
PostOrder
*
Kết quả
11 10 1 3
10 11 5 4 1 3 8
5 11 6 4 9 10 1 8 3 2 7
5 6 9 4 11 1 8 2 7 3 10
*/


======================================== ./tuan7/b7(Tree_manipulation_query_depth_-_height).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int id;
    struct Node *children[100];
    int childCount;
    struct Node *parent;
} Node;

#define MAXN 50005
Node *nodes[MAXN];
Node *root = NULL;

// Tạo hoặc lấy node theo id
Node *getNode(int id) {
    if (nodes[id] == NULL) {
        nodes[id] = (Node *)malloc(sizeof(Node));
        nodes[id]->id = id;
        nodes[id]->childCount = 0;
        nodes[id]->parent = NULL;
    }
    return nodes[id];
}

// Tính độ cao của nút (số tầng từ nút đến lá sâu nhất)
int getHeight(Node *node) {
    if (!node)
        return 0;
    int maxH = 0;
    for (int i = 0; i < node->childCount; i++) {
        int h = getHeight(node->children[i]);
        if (h > maxH)
            maxH = h;
    }
    return maxH + 1; // bao gồm chính nó
}

// Tính độ sâu của nút (số tầng từ gốc đến nút)
int getDepth(Node *node) {
    int depth = 1; // gốc có độ sâu là 1
    while (node && node->parent) {
        node = node->parent;
        depth++;
    }
    return depth;
}

int main() {
    char cmd[20];
    int u, v;

    for (int i = 0; i < MAXN; i++)
        nodes[i] = NULL;

    while (scanf("%s", cmd)) {
        if (strcmp(cmd, "*") == 0)
            break;

        if (strcmp(cmd, "MakeRoot") == 0) {
            scanf("%d", &u);
            root = getNode(u);
        } else if (strcmp(cmd, "Insert") == 0) {
            scanf("%d %d", &u, &v);
            if (!nodes[u] && nodes[v]) {
                Node *child = getNode(u);
                Node *parent = nodes[v];
                parent->children[parent->childCount++] = child;
                child->parent = parent;
            }
        } else if (strcmp(cmd, "Height") == 0) {
            scanf("%d", &u);
            printf("%d\n", getHeight(nodes[u]));
        } else if (strcmp(cmd, "Depth") == 0) {
            scanf("%d", &u);
            printf("%d\n", getDepth(nodes[u]));
        }
    }

    return 0;
}
/*
Dữ liệu
MakeRoot 10
Insert 11 10
Insert 1 10
Insert 3 10
Insert 5 11
Insert 4 11
Height 10
Depth 10
Insert 8 3
Insert 2 3
Insert 7 3
Insert 6 4
Insert 9 4
Height 10
Depth 10
Depth 3
*
Kết quả
3
1
4
1
2
*/


======================================== ./tuan8/b1(Classification_of_students_based_on_grades).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char id[11];
    int grade;
    int position;
} Student;

int compareGrade(const void *a, const void *b) {
    return ((Student *)a)->grade - ((Student *)b)->grade;
}

int compareID(const void *a, const void *b) {
    return strcmp(((Student *)a)->id, ((Student *)b)->id);
}

int main() {
    int n;
    scanf("%d", &n);

    Student *students = (Student *)malloc(n * sizeof(Student));

    for (int i = 0; i < n; i++) {
        scanf("%s %d", students[i].id, &students[i].grade);
    }
    qsort(students, n, sizeof(Student), compareGrade);
    for (int i = 0; i < n; i++) {
        students[i].position = i;
    }
    qsort(students, n, sizeof(Student), compareID);
    for (int i = 0; i < n; i++) {
        printf("%s %d\n", students[i].id, students[i].position);
    }

    free(students);
    return 0;
}
/*
Input
5
S000003 3
S000002 6
S000005 5
S000004 10
S000001 8

Output
S000001 3
S000002 2
S000003 0
S000004 4
S000005 1
*/


======================================== ./tuan8/b2(Max_Cardinality_Common_Subset_of_2_Sets).c ========================================

#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a, const void *b) {
    int x = *(int *)a;
    int y = *(int *)b;
    if (x < y)
        return -1;
    if (x > y)
        return 1;
    return 0;
}

int main() {
    int n, m;
    scanf("%d %d", &n, &m);

    int *A = (int *)malloc(n * sizeof(int));
    int *B = (int *)malloc(m * sizeof(int));

    for (int i = 0; i < n; i++)
        scanf("%d", &A[i]);
    for (int j = 0; j < m; j++)
        scanf("%d", &B[j]);
    qsort(B, m, sizeof(int), cmp);

    int count = 0;
    for (int i = 0; i < n; i++) {
        if (bsearch(&A[i], B, m, sizeof(int), cmp) != NULL) {
            count++;
        }
    }

    printf("%d\n", count);

    free(A);
    free(B);
    return 0;
}
/*
Example
Input
6 6
7 3 10 1 2 8
6 2 8 10 5 7

Output
4

Explanation. The max-cardinality common subset of A and B is {2, 8, 10, 7}
*/


======================================== ./tuan8/b3(Pair_sum).c ========================================

#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}

long long count_pairs(int *a, int n, long long x) {
    int l = 0, r = n - 1;
    long long ans = 0;

    while (l < r) {
        if ((long long)a[l] + a[r] <= x) {
            ans += (r - l); // tất cả cặp (l, l+1..r)
            l++;
        } else {
            r--;
        }
    }

    return ans;
}

int main() {
    int n;
    scanf("%d", &n);

    int *a = (int *)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++)
        scanf("%d", &a[i]);

    qsort(a, n, sizeof(int), cmp);

    int q;
    scanf("%d", &q);

    while (q--) {
        long long x;
        scanf("%lld", &x);
        printf("%lld\n", count_pairs(a, n, x));
    }

    free(a);
    return 0;
}
/*
Input:
5
5 10 2 7 9
2
15
13
Output:
7
5
*/


======================================== ./tuan8/b4(Sort_a_sequence_of_integers).c ========================================

#include <stdio.h>

#define MAXA 100000

int cnt[MAXA + 1];

int main() {
    int n, x;
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        scanf("%d", &x);
        cnt[x]++;
    }

    int printed = 0;
    for (int v = 0; v <= MAXA; v++) {
        while (cnt[v] > 0) {
            printf("%d", v);
            printed++;
            if (printed < n)
                printf(" ");
            cnt[v]--;
        }
    }
    return 0;
}
/*
Input
4
1 3 4 2
Output
1 2 3 4
*/


======================================== ./tuan8/b5(Sort_candidates_of_a_Contest).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef struct {
    char code[15];
    int score;
} Candidate;

int cmp(const void *a, const void *b) {
    Candidate *x = (Candidate *)a;
    Candidate *y = (Candidate *)b;
    return y->score - x->score; // giảm dần
}

int main() {
    Candidate a[1000005];
    int n = 0;

    char code[15];
    int score;

    while (1) {
        if (scanf("%s", code) != 1)
            return 0;

        if (strcmp(code, "#") == 0)
            break;

        scanf("%d", &score);

        strcpy(a[n].code, code);
        a[n].score = score;
        n++;
    }

    qsort(a, n, sizeof(Candidate), cmp);

    for (int i = 0; i < n; i++) {
        printf("%s %d\n", a[i].code, a[i].score);
    }

    return 0;
}
/*
Input
S00001 27412
S00002 22981
S00003 32561
S00004 10915
S00005 17566
#

Output
S00003 32561
S00001 27412
S00002 22981
S00005 17566
S00004 10915
*/


======================================== ./tuan8/b6(Sort_Strings).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Comparator function for qsort
int cmp(const void *a, const void *b) {
    return strcmp(*(const char **)a, *(const char **)b);
}

int main() {
    int n;
    scanf("%d", &n);

    // Allocate array of string pointers
    char **arr = (char **)malloc(n * sizeof(char *));
    for (int i = 0; i < n; i++) {
        arr[i] = (char *)malloc(105 * sizeof(char)); // assuming max length ~100
        scanf("%s", arr[i]);
    }

    // Sort using qsort
    qsort(arr, n, sizeof(char *), cmp);

    // Print sorted strings
    for (int i = 0; i < n; i++) {
        printf("%s\n", arr[i]);
        free(arr[i]); // free each string
    }
    free(arr); // free array of pointers

    return 0;
}
/*
Input
10
O0001
Z002
R003
R00004
P05
P00006
T0007
X08
N09
I010

Output
I010
N09
O0001
P00006
P05
R00004
R003
T0007
X08
Z002
*/


======================================== ./tuan8/b7(Sort_vectors_in_a_lexicographic_order).c ========================================

#include <stdio.h>
#include <stdlib.h>

int n, m;
int a[100000][10];

int cmp(const void *x, const void *y) {
    const int *v1 = (const int *)x;
    const int *v2 = (const int *)y;

    for (int i = 0; i < m; i++) {
        if (v1[i] < v2[i])
            return -1;
        if (v1[i] > v2[i])
            return 1;
    }
    return 0;
}

int main() {
    scanf("%d %d", &n, &m);

    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            scanf("%d", &a[i][j]);

    qsort(a, n, sizeof(a[0]), cmp);

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++)
            printf("%d ", a[i][j]);
        printf("\n");
    }

    return 0;
}
/*
Input
6 3
10 9 7
5 10 2
10 9 1
4 7 3
7 5 10
7 9 3

Output
4 7 3
5 10 2
7 5 10
7 9 3
10 9 1
10 9 7
*/


======================================== ./tuan9/b1(Count_number_of_pairs_of_sequence_of_distinct_integer_sum_equal_to_Q).c ========================================

#include <stdio.h>
#include <stdlib.h>

int cmp(const void *a, const void *b) {
    return *(int *)a - *(int *)b;
}

int main() {
    int n, Q;
    scanf("%d %d", &n, &Q);
    int *a = (int *)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    qsort(a, n, sizeof(int), cmp);
    int left = 0, right = n - 1, count = 0;
    while (left < right) {
        if (a[left] + a[right] == Q) {
            count++;
            left++;
            right--;
        } else if (a[left] + a[right] < Q) {
            left++;
        } else {
            right--;
        }
    }
    printf("%d\n", count);
    free(a);
    return 0;
}
/*
Input
5 8
4 6 5 3 2
Output
2
*/


======================================== ./tuan9/b10(BANK_-_Query_Total_transaction_from).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LEN 25
#define HASH_SIZE 200003 // số nguyên tố lớn

typedef struct Node {
    char account[MAX_LEN];
    long total;
    struct Node *next;
} Node;

Node *hash_table[HASH_SIZE];

/* hash function (djb2) */
unsigned int hash(const char *s) {
    unsigned int h = 5381;
    while (*s)
        h = ((h << 5) + h) + (*s++);
    return h % HASH_SIZE;
}

/* add money to account */
void add_money(const char *acc, int money) {
    unsigned int h = hash(acc);
    Node *cur = hash_table[h];

    while (cur) {
        if (strcmp(cur->account, acc) == 0) {
            cur->total += money;
            return;
        }
        cur = cur->next;
    }

    // chưa tồn tại
    Node *node = (Node *)malloc(sizeof(Node));
    strcpy(node->account, acc);
    node->total = money;
    node->next = hash_table[h];
    hash_table[h] = node;
}

/* get total money */
long get_total(const char *acc) {
    unsigned int h = hash(acc);
    Node *cur = hash_table[h];

    while (cur) {
        if (strcmp(cur->account, acc) == 0)
            return cur->total;
        cur = cur->next;
    }
    return 0;
}

int main() {
    char from[MAX_LEN], to[MAX_LEN], time[10], atm[15];
    int money;

    /* DATA BLOCK */
    while (1) {
        char line[200];
        if (!fgets(line, sizeof(line), stdin))
            break;
        if (line[0] == '#')
            break;

        sscanf(line, "%s %s %d %s %s", from, to, &money, time, atm);

        add_money(from, money);
    }

    /* QUERY BLOCK */
    while (1) {
        char line[100], acc[MAX_LEN];
        if (!fgets(line, sizeof(line), stdin))
            break;
        if (line[0] == '#')
            break;

        sscanf(line, "?total_money_transaction_from %s", acc);
        printf("%ld\n", get_total(acc));
    }

    return 0;
}
/*
Input
T000010010 T000010020 1000 10:20:30 ATM1
T000010010 T000010030 2000 10:02:30 ATM2
T000010010 T000010040 1500 09:23:30 ATM1
T000010020 T000010030 3000 08:20:31 ATM1
T000010030 T000010010 4000 12:40:00 ATM2
T000010040 T000010010 2000 10:30:00 ATM1
T000010020 T000010040 3000 08:20:31 ATM1
T000010040 T000010030 2000 11:30:00 ATM1
T000010040 T000010030 1000 18:30:00 ATM1
#
?total_money_transaction_from T000010010
?total_money_transaction_from T000010030
#
Output
4500
4000
*/


======================================== ./tuan9/b11(BST_-_Insertion_and_PreOrder_Traversal).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int key;
    struct Node *left, *right;
} Node;

/* tạo node mới */
Node *newNode(int k) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = k;
    p->left = p->right = NULL;
    return p;
}

/* insert vào BST, không chèn nếu trùng */
Node *insert(Node *root, int k) {
    if (root == NULL)
        return newNode(k);

    if (k < root->key)
        root->left = insert(root->left, k);
    else if (k > root->key)
        root->right = insert(root->right, k);

    return root; // k == root->key thì bỏ qua
}

/* duyệt pre-order */
void preorder(Node *root) {
    if (root == NULL)
        return;
    printf("%d ", root->key);
    preorder(root->left);
    preorder(root->right);
}

int main() {
    Node *root = NULL;
    char cmd[20];
    int k;

    while (1) {
        if (scanf("%s", cmd) != 1)
            break;
        if (cmd[0] == '#')
            break;

        if (strcmp(cmd, "insert") == 0) {
            scanf("%d", &k);
            root = insert(root, k);
        }
    }

    preorder(root);
    return 0;
}
/*
Input
insert 20
insert 10
insert 26
insert 7
insert 15
insert 23
insert 30
insert 3
insert 8
#
Output
20 10 7 3 8 15 26 23 30
*/


======================================== ./tuan9/b12(BST_Creation_and_Query_about_PreOrder_and_PostOrder_Traversal).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int key;
    struct Node *left, *right;
} Node;

/* tạo node mới */
Node *newNode(int k) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = k;
    p->left = p->right = NULL;
    return p;
}

/* insert vào BST, bỏ qua nếu trùng */
Node *insert(Node *root, int k) {
    if (root == NULL)
        return newNode(k);

    if (k < root->key)
        root->left = insert(root->left, k);
    else if (k > root->key)
        root->right = insert(root->right, k);

    return root;
}

/* preorder traversal */
void preorder(Node *root) {
    if (root == NULL)
        return;
    printf("%d ", root->key);
    preorder(root->left);
    preorder(root->right);
}

/* postorder traversal */
void postorder(Node *root) {
    if (root == NULL)
        return;
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->key);
}

int main() {
    Node *root = NULL;
    char cmd[30];
    int k;

    while (1) {
        if (scanf("%s", cmd) != 1)
            break;
        if (cmd[0] == '#')
            break;

        if (strcmp(cmd, "insert") == 0) {
            scanf("%d", &k);
            root = insert(root, k);
        } else if (strcmp(cmd, "preorder") == 0) {
            preorder(root);
            printf("\n");
        } else if (strcmp(cmd, "postorder") == 0) {
            postorder(root);
            printf("\n");
        }
    }

    return 0;
}
/*
Input
insert 5
insert 9
insert 2
insert 1
preorder
insert 8
insert 5
insert 3
postorder
#

Output
5 2 1 9
1 3 2 8 9 5
*/


======================================== ./tuan9/b2(Check_Existence_in_a_Set).c ========================================

#include <stdio.h>
#include <stdlib.h>

#define HASH_SIZE 1000003

typedef struct Node {
    long long key;
    struct Node *next;
} Node;

Node *hash_table[HASH_SIZE];

long long hash_func(long long key) {
    return (key % HASH_SIZE + HASH_SIZE) % HASH_SIZE;
}

int has_key(long long key) {
    long long h = hash_func(key);
    Node *node = hash_table[h];
    while (node) {
        if (node->key == key)
            return 1;
        node = node->next;
    }
    return 0;
}

void insert(long long key) {
    long long h = hash_func(key);
    Node *node = (Node *)malloc(sizeof(Node));
    node->key = key;
    node->next = hash_table[h];
    hash_table[h] = node;
}

int main() {
    int n;
    scanf("%d", &n);
    long long *a = (long long *)malloc(n * sizeof(long long));
    for (int i = 0; i < n; i++) {
        scanf("%lld", &a[i]);
    }
    for (int i = 0; i < n; i++) {
        if (has_key(a[i])) {
            printf("1\n");
        } else {
            printf("0\n");
        }
        insert(a[i]);
    }
    free(a);
    return 0;
}
/*
input
5
1 4 3 1 4
output
0
0
0
1
1
*/


======================================== ./tuan9/b3(Hash_Over_Integers).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define HASH_SIZE 1000003

typedef struct Node {
    long long key;
    struct Node *next;
} Node;

Node *hash_table[HASH_SIZE];

long long hash_func(long long key) {
    return (key % HASH_SIZE + HASH_SIZE) % HASH_SIZE;
}

int has_key(long long key) {
    long long h = hash_func(key);
    Node *node = hash_table[h];
    while (node) {
        if (node->key == key)
            return 1;
        node = node->next;
    }
    return 0;
}

void insert_key(long long key) {
    long long h = hash_func(key);
    Node *node = (Node *)malloc(sizeof(Node));
    node->key = key;
    node->next = hash_table[h];
    hash_table[h] = node;
}

int main() {
    char line[100];
    while (fgets(line, sizeof(line), stdin)) {
        if (line[0] == '*' && line[1] == '\n')
            break;
        long long k = atoll(line);
        insert_key(k);
    }
    while (fgets(line, sizeof(line), stdin)) {
        if (strncmp(line, "***", 3) == 0)
            break;
        char cmd[10];
        long long k;
        sscanf(line, "%s %lld", cmd, &k);
        if (strcmp(cmd, "find") == 0) {
            printf("%d\n", has_key(k));
        } else if (strcmp(cmd, "insert") == 0) {
            if (!has_key(k)) {
                insert_key(k);
                printf("1\n");
            } else {
                printf("0\n");
            }
        }
    }
    return 0;
}
/*
Input
4
5
2
*
find 3
insert 4
find 2
insert 3
find 3
***
Output
0
0
1
1
1
*/


======================================== ./tuan9/b4(Hash_Over_Strings).c ========================================

#include <stdio.h>
#include <string.h>

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    for (int i = 0; i < n; i++) {
        char str[201];
        scanf("%s", str);
        long long hash = 0;
        for (int j = 0; str[j]; j++) {
            hash = (hash * 256LL + str[j]) % m;
        }
        printf("%lld\n", hash);
    }
    return 0;
}
/*
Input
4 1000
a
ab
abc
abcd
Output
97
930
179
924
*/


======================================== ./tuan9/b5(Store_&_Search_String).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define HASH_SIZE 1000003

typedef struct Node {
    char key[51];
    struct Node *next;
} Node;

Node *hash_table[HASH_SIZE];

long long hash_func(char *s) {
    long long h = 0;
    for (int i = 0; s[i]; i++) {
        h = (h * 256LL + s[i]) % HASH_SIZE;
    }
    return h;
}

int has_key(char *k) {
    long long h = hash_func(k);
    Node *node = hash_table[h];
    while (node) {
        if (strcmp(node->key, k) == 0)
            return 1;
        node = node->next;
    }
    return 0;
}

void insert_key(char *k) {
    long long h = hash_func(k);
    Node *node = (Node *)malloc(sizeof(Node));
    strcpy(node->key, k);
    node->next = hash_table[h];
    hash_table[h] = node;
}

int main() {
    char line[100];
    while (fgets(line, sizeof(line), stdin)) {
        line[strcspn(line, "\n")] = 0;
        if (strcmp(line, "*") == 0)
            break;
        insert_key(line);
    }
    while (fgets(line, sizeof(line), stdin)) {
        line[strcspn(line, "\n")] = 0;
        if (strcmp(line, "***") == 0)
            break;
        char cmd[10];
        char k[51];
        sscanf(line, "%s %s", cmd, k);
        if (strcmp(cmd, "find") == 0) {
            printf("%d\n", has_key(k));
        } else if (strcmp(cmd, "insert") == 0) {
            if (!has_key(k)) {
                insert_key(k);
                printf("1\n");
            } else {
                printf("0\n");
            }
        }
    }
    return 0;
}
/*
Input
computer
university
school
technology
phone
*
find school
find book
insert book
find algorithm
find book
insert book
***
Output
1
0
1
0
1
0
*/


======================================== ./tuan9/b6(Word_Frequency_in_Text).c ========================================

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define HASH_SIZE 1000003

typedef struct Node {
    char word[21];
    int count;
    struct Node *next;
} Node;

Node *hash_table[HASH_SIZE];

long long hash_func(char *s) {
    long long h = 0;
    for (int i = 0; s[i]; i++) {
        h = (h * 256LL + s[i]) % HASH_SIZE;
    }
    return h;
}

Node *has_key(char *k) {
    long long h = hash_func(k);
    Node *node = hash_table[h];
    while (node) {
        if (strcmp(node->word, k) == 0)
            return node;
        node = node->next;
    }
    return NULL;
}

void insert_key(char *k) {
    long long h = hash_func(k);
    Node *node = (Node *)malloc(sizeof(Node));
    strcpy(node->word, k);
    node->count = 1;
    node->next = hash_table[h];
    hash_table[h] = node;
}

int cmp(const void *a, const void *b) {
    Node *na = *(Node **)a;
    Node *nb = *(Node **)b;
    return strcmp(na->word, nb->word);
}

int main() {
    char buffer[1000000];
    int len = 0;
    char line[1000];
    while (fgets(line, sizeof(line), stdin)) {
        strcpy(buffer + len, line);
        len += strlen(line);
    }
    buffer[len] = 0;
    char *p = buffer;
    char word[21];
    int i = 0;
    while (*p) {
        if (isalnum(*p)) {
            if (i < 20) {
                word[i++] = *p;
            }
        } else {
            if (i > 0) {
                word[i] = 0;
                Node *node = has_key(word);
                if (node) {
                    node->count++;
                } else {
                    insert_key(word);
                }
                i = 0;
            }
        }
        p++;
    }
    if (i > 0) {
        word[i] = 0;
        Node *node = has_key(word);
        if (node) {
            node->count++;
        } else {
            insert_key(word);
        }
    }
    Node *all_words[10000];
    int num_words = 0;
    for (int j = 0; j < HASH_SIZE; j++) {
        Node *node = hash_table[j];
        while (node) {
            all_words[num_words++] = node;
            node = node->next;
        }
    }
    qsort(all_words, num_words, sizeof(Node *), cmp);
    for (int j = 0; j < num_words; j++) {
        printf("%s %d\n", all_words[j]->word, all_words[j]->count);
    }
    return 0;
}
/*
Input
abc  def abc
abc abcd def

Output
abc 3
abcd 1
def 2
*/


======================================== ./tuan9/b7(BST_with_insertion_and_removal_operations).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Node {
    int key;
    struct Node *left, *right;
} Node;

/* tạo node mới */
Node *newNode(int k) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = k;
    p->left = p->right = NULL;
    return p;
}

/* insert vào BST, bỏ qua nếu trùng */
Node *insert(Node *root, int k) {
    if (root == NULL)
        return newNode(k);

    if (k < root->key)
        root->left = insert(root->left, k);
    else if (k > root->key)
        root->right = insert(root->right, k);

    return root;
}

/* tìm node nhỏ nhất */
Node *minNode(Node *root) {
    while (root && root->left)
        root = root->left;
    return root;
}

/* remove node có key = k */
Node *removeNode(Node *root, int k) {
    if (root == NULL)
        return NULL;

    if (k < root->key) {
        root->left = removeNode(root->left, k);
    } else if (k > root->key) {
        root->right = removeNode(root->right, k);
    } else {
        // tìm thấy node cần xóa
        if (root->left == NULL) {
            Node *tmp = root->right;
            free(root);
            return tmp;
        } else if (root->right == NULL) {
            Node *tmp = root->left;
            free(root);
            return tmp;
        } else {
            // có 2 con
            Node *tmp = minNode(root->right);
            root->key = tmp->key;
            root->right = removeNode(root->right, tmp->key);
        }
    }
    return root;
}

/* preorder */
void preorder(Node *root) {
    if (!root)
        return;
    printf("%d ", root->key);
    preorder(root->left);
    preorder(root->right);
}

/* postorder */
void postorder(Node *root) {
    if (!root)
        return;
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->key);
}

int main() {
    Node *root = NULL;
    char cmd[30];
    int k;

    while (1) {
        if (scanf("%s", cmd) != 1)
            break;
        if (cmd[0] == '#')
            break;

        if (strcmp(cmd, "insert") == 0) {
            scanf("%d", &k);
            root = insert(root, k);
        } else if (strcmp(cmd, "remove") == 0) {
            scanf("%d", &k);
            root = removeNode(root, k);
        } else if (strcmp(cmd, "preorder") == 0) {
            preorder(root);
            printf("\n");
        } else if (strcmp(cmd, "postorder") == 0) {
            postorder(root);
            printf("\n");
        }
    }

    return 0;
}
/*
Input
insert 3
insert 4
remove 4
preorder
postorder
insert 5
insert 1
insert 8
remove 1
preorder
postorder
#

Output
3
3
3 5 8
8 5 3k

*/


======================================== ./tuan9/b8(BST_Build_the_BST_from_pre-order_sequence_of_nodes).c ========================================

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>


typedef struct Node {
    int key;
    struct Node *left;
    struct Node *right;
} Node;

int *a;
int n;
int idx;

Node *create_node(int key) {
    Node *node = (Node *)malloc(sizeof(Node));
    node->key = key;
    node->left = node->right = NULL;
    return node;
}

Node *build(int min, int max) {
    if (idx >= n)
        return NULL;
    int val = a[idx];
    if (val <= min || val >= max)
        return NULL;
    idx++;
    Node *node = create_node(val);
    node->left = build(min, val);
    node->right = build(val, max);
    return node;
}

int keys[50000];
int key_count;

void collect_postorder(Node *root) {
    if (root) {
        collect_postorder(root->left);
        collect_postorder(root->right);
        keys[key_count++] = root->key;
    }
}

int main() {
    scanf("%d", &n);
    a = (int *)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    idx = 0;
    Node *root = build(INT_MIN, INT_MAX);
    if (root && idx == n) {
        key_count = 0;
        collect_postorder(root);
        for (int i = 0; i < key_count; i++) {
            printf("%d", keys[i]);
            if (i < key_count - 1)
                printf(" ");
        }
        printf("\n");
    } else {
        printf("NULL\n");
    }
    free(a);
    return 0;
}
/*
Input
11
10 5 2 3 8 7 9 20 15 18 40
Output
3 2 7 9 8 5 18 15 40 20 10


Example
Input
11
10 5 2 3 8 7 9 20 15 18 4
Output
NULL

*/


======================================== ./tuan9/b9(Analyze_sales_order_of_an_e-commerce_company).c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct Order {
    char customer[11];
    char product[11];
    int price;
    char shop[11];
    int time_sec;
} Order;

typedef struct ShopNode {
    char shop[11];
    long long sum;
    struct ShopNode *next;
} ShopNode;

typedef struct CustShopNode {
    char key[22];
    long long sum;
    struct CustShopNode *next;
} CustShopNode;

Order orders[100000];
int num_orders = 0;
long long total_revenue = 0;
ShopNode *shop_hash[1000003];
CustShopNode *custshop_hash[1000003];
int order_indices[100000];
long long prefix[100001];

long long hash_func(char *s) {
    long long h = 0;
    for (int i = 0; s[i]; i++) {
        h = (h * 256LL + s[i]) % 1000003;
    }
    return h;
}

void add_shop(char *shop, int price) {
    long long h = hash_func(shop);
    ShopNode *node = shop_hash[h];
    while (node) {
        if (strcmp(node->shop, shop) == 0) {
            node->sum += price;
            return;
        }
        node = node->next;
    }
    node = (ShopNode *)malloc(sizeof(ShopNode));
    strcpy(node->shop, shop);
    node->sum = price;
    node->next = shop_hash[h];
    shop_hash[h] = node;
}

long long get_shop_sum(char *shop) {
    long long h = hash_func(shop);
    ShopNode *node = shop_hash[h];
    while (node) {
        if (strcmp(node->shop, shop) == 0)
            return node->sum;
        node = node->next;
    }
    return 0;
}

void add_custshop(char *customer, char *shop, int price) {
    char key[22];
    strcpy(key, customer);
    strcat(key, shop);
    long long h = hash_func(key);
    CustShopNode *node = custshop_hash[h];
    while (node) {
        if (strcmp(node->key, key) == 0) {
            node->sum += price;
            return;
        }
        node = node->next;
    }
    node = (CustShopNode *)malloc(sizeof(CustShopNode));
    strcpy(node->key, key);
    node->sum = price;
    node->next = custshop_hash[h];
    custshop_hash[h] = node;
}

long long get_custshop_sum(char *customer, char *shop) {
    char key[22];
    strcpy(key, customer);
    strcat(key, shop);
    long long h = hash_func(key);
    CustShopNode *node = custshop_hash[h];
    while (node) {
        if (strcmp(node->key, key) == 0)
            return node->sum;
        node = node->next;
    }
    return 0;
}

int time_to_seconds(char *time) {
    int h, m, s;
    sscanf(time, "%d:%d:%d", &h, &m, &s);
    return h * 3600 + m * 60 + s;
}

int cmp_time(const void *a, const void *b) {
    int ia = *(int *)a;
    int ib = *(int *)b;
    return orders[ia].time_sec - orders[ib].time_sec;
}

int main() {
    char line[100];
    while (fgets(line, sizeof(line), stdin)) {
        line[strcspn(line, "\n")] = 0;
        if (strcmp(line, "#") == 0)
            break;
        char customer[11], product[11], shop[11], time_str[9];
        int price;
        sscanf(line, "%s %s %d %s %s", customer, product, &price, shop,
               time_str);
        int time_sec = time_to_seconds(time_str);
        strcpy(orders[num_orders].customer, customer);
        strcpy(orders[num_orders].product, product);
        orders[num_orders].price = price;
        strcpy(orders[num_orders].shop, shop);
        orders[num_orders].time_sec = time_sec;
        add_shop(shop, price);
        add_custshop(customer, shop, price);
        total_revenue += price;
        num_orders++;
    }
    // prepare time
    for (int i = 0; i < num_orders; i++)
        order_indices[i] = i;
    qsort(order_indices, num_orders, sizeof(int), cmp_time);
    prefix[0] = 0;
    for (int i = 1; i <= num_orders; i++) {
        prefix[i] = prefix[i - 1] + orders[order_indices[i - 1]].price;
    }
    // queries
    while (fgets(line, sizeof(line), stdin)) {
        line[strcspn(line, "\n")] = 0;
        if (strcmp(line, "#") == 0)
            break;
        char *query = strtok(line, " ");
        if (strcmp(query, "?total_number_orders") == 0) {
            printf("%d\n", num_orders);
        } else if (strcmp(query, "?total_revenue") == 0) {
            printf("%lld\n", total_revenue);
        } else if (strcmp(query, "?revenue_of_shop") == 0) {
            char *shop = strtok(NULL, " ");
            printf("%lld\n", get_shop_sum(shop));
        } else if (strcmp(query, "?total_consume_of_customer_shop") == 0) {
            char *customer = strtok(NULL, " ");
            char *shop = strtok(NULL, " ");
            printf("%lld\n", get_custshop_sum(customer, shop));
        } else if (strcmp(query, "?total_revenue_in_period") == 0) {
            char *from = strtok(NULL, " ");
            char *to = strtok(NULL, " ");
            int from_sec = time_to_seconds(from);
            int to_sec = time_to_seconds(to);
            int low = 0, high = num_orders;
            while (low < high) {
                int mid = (low + high) / 2;
                if (orders[order_indices[mid]].time_sec >= from_sec)
                    high = mid;
                else
                    low = mid + 1;
            }
            int start = low;
            low = 0, high = num_orders;
            while (low < high) {
                int mid = (low + high) / 2;
                if (orders[order_indices[mid]].time_sec > to_sec)
                    high = mid;
                else
                    low = mid + 1;
            }
            int end = low;
            long long sum = prefix[end] - prefix[start];
            printf("%lld\n", sum);
        }
    }
    return 0;
}
/*
Input
C001 P001 10 SHOP001 10:30:10
C001 P002 30 SHOP001 12:30:10
C003 P001 40 SHOP002 10:15:20
C001 P001 80 SHOP002 08:40:10
C002 P001 130 SHOP001 10:30:10
C002 P001 160 SHOP003 11:30:20
#
?total_number_orders
?total_revenue
?revenue_of_shop SHOP001
?total_consume_of_customer_shop C001 SHOP001
?total_revenue_in_period 10:00:00 18:40:45
#


Output
6
450
170
40
370
*/



======================================== ./tuana/Check_Bipartite_Graph.c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 100005

int main() {
    int n, m;
    scanf("%d %d", &n, &m);

    // Adjacency list
    int *adj[MAX_N];
    int adj_count[MAX_N] = {0};

    // Allocate space for adjacency list
    for (int i = 1; i <= n; i++) {
        adj[i] = (int *)malloc((m + 1) * sizeof(int));
    }

    // Read edges
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);

        adj[u][adj_count[u]++] = v;
        adj[v][adj_count[v]++] = u;
    }

    // Color array: -1 = unvisited, 0 and 1 = two colors
    int color[MAX_N];
    memset(color, -1, sizeof(color));

    int is_bipartite = 1;

    // BFS for each connected component
    for (int start = 1; start <= n && is_bipartite; start++) {
        if (color[start] == -1) {
            // BFS from start vertex
            int queue[MAX_N];
            int front = 0, rear = 0;

            queue[rear++] = start;
            color[start] = 0;

            while (front < rear && is_bipartite) {
                int u = queue[front++];

                // Check all neighbors
                for (int i = 0; i < adj_count[u]; i++) {
                    int v = adj[u][i];

                    if (color[v] == -1) {
                        // Color with opposite color
                        color[v] = 1 - color[u];
                        queue[rear++] = v;
                    } else if (color[v] == color[u]) {
                        // Same color as neighbor - not bipartite
                        is_bipartite = 0;
                        break;
                    }
                }
            }
        }
    }

    printf("%d\n", is_bipartite);

    // Free allocated memory
    for (int i = 1; i <= n; i++) {
        free(adj[i]);
    }

    return 0;
}
/*
input
6 6
1 2
1 3
2 5
2 6
4 5
4 6

output
1
*/


======================================== ./tuana/Connected_Components_of_undirected_graphs.c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_N 100005

int *adj[MAX_N];
int adj_count[MAX_N];
int visited[MAX_N];

void dfs(int u) {
    visited[u] = 1;

    for (int i = 0; i < adj_count[u]; i++) {
        int v = adj[u][i];
        if (!visited[v]) {
            dfs(v);
        }
    }
}

int main() {
    int n, m;
    scanf("%d %d", &n, &m);

    // Initialize adjacency list
    for (int i = 1; i <= n; i++) {
        adj[i] = (int *)malloc((m + 1) * sizeof(int));
        adj_count[i] = 0;
    }

    // Read edges
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);

        adj[u][adj_count[u]++] = v;
        adj[v][adj_count[v]++] = u;
    }

    // Count connected components
    int components = 0;
    for (int i = 1; i <= n; i++) {
        if (!visited[i]) {
            dfs(i);
            components++;
        }
    }

    printf("%d\n", components);

    // Free allocated memory
    for (int i = 1; i <= n; i++) {
        free(adj[i]);
    }

    return 0;
}
/*
Input
8 8
1 2
1 7
1 8
2 7
4 5
4 6
5 6
7 8

Output
3
*/


======================================== ./tuana/Disjoint_Segment.c ========================================

#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int a, b;
} Segment;

int cmp(const void *x, const void *y) {
    const Segment *s1 = (const Segment *)x;
    const Segment *s2 = (const Segment *)y;
    if (s1->b != s2->b)
        return s1->b - s2->b;
    return s1->a - s2->a;
}

int main() {
    int n;
    if (scanf("%d", &n) != 1)
        return 0;
    Segment *seg = (Segment *)malloc((size_t)n * sizeof(Segment));
    for (int i = 0; i < n; i++) {
        scanf("%d %d", &seg[i].a, &seg[i].b);
    }

    qsort(seg, n, sizeof(Segment), cmp);

    int count = 0;
    int last_end = -1; // a_i >= 0 theo đề
    for (int i = 0; i < n; i++) {
        if (seg[i].a > last_end) { // nghiêm: không cho chạm tại điểm
            count++;
            last_end = seg[i].b;
        }
    }

    printf("%d\n", count);
    free(seg);
    return 0;
}
/*
Input
6
0 10
3 7
6 14
9 11
12 15
17 19

Output
4
*/


======================================== ./tuana/Longest_Common_Subsequence.c ========================================

#include <stdio.h>
#define max(a, b) ((a) > (b) ? (a) : (b))

int main() {
    int n, m;
    scanf("%d %d", &n, &m);
    int X[n + 1], Y[m + 1];
    for (int i = 1; i <= n; i++)
        scanf("%d", &X[i]);
    for (int j = 1; j <= m; j++)
        scanf("%d", &Y[j]);

    static int dp[10001][10001]; // dùng static để lưu trên vùng nhớ toàn cục

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (X[i] == Y[j])
                dp[i][j] = dp[i - 1][j - 1] + 1;
            else
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }

    printf("%d", dp[n][m]);
    return 0;
}
/*
Input
7 10
3 7 2 5 1 4 9
4 3 2 3 6 1 5 4 9 7
Output
5
*/


======================================== ./tuana/Minimum Spanning Tree - Kruskal.c ========================================

#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int u, v, weight;
} Edge;

typedef struct {
    int parent;
    int rank;
} Node;

int find(Node *parent, int x) {
    if (parent[x].parent != x) {
        parent[x].parent = find(parent, parent[x].parent);
    }
    return parent[x].parent;
}

void unite(Node *parent, int x, int y) {
    int px = find(parent, x);
    int py = find(parent, y);

    if (px == py)
        return;

    if (parent[px].rank < parent[py].rank) {
        parent[px].parent = py;
    } else if (parent[px].rank > parent[py].rank) {
        parent[py].parent = px;
    } else {
        parent[py].parent = px;
        parent[px].rank++;
    }
}

int compare(const void *a, const void *b) {
    return ((Edge *)a)->weight - ((Edge *)b)->weight;
}

int main() {
    int n, m;
    scanf("%d %d", &n, &m);

    Edge *edges = (Edge *)malloc(m * sizeof(Edge));
    Node *parent = (Node *)malloc(n * sizeof(Node));

    for (int i = 0; i < n; i++) {
        parent[i].parent = i;
        parent[i].rank = 0;
    }

    for (int i = 0; i < m; i++) {
        scanf("%d %d %d", &edges[i].u, &edges[i].v, &edges[i].weight);
        edges[i].u--; // Convert to 0-indexed
        edges[i].v--;
    }

    // Sort edges by weight
    qsort(edges, m, sizeof(Edge), compare);

    int totalWeight = 0;
    int edgeCount = 0;

    for (int i = 0; i < m && edgeCount < n - 1; i++) {
        int pu = find(parent, edges[i].u);
        int pv = find(parent, edges[i].v);

        if (pu != pv) {
            unite(parent, pu, pv);
            totalWeight += edges[i].weight;
            edgeCount++;
        }
    }

    printf("%d\n", totalWeight);

    free(edges);
    free(parent);

    return 0;
}
/*
Input
5 8
1 2 1
1 3 4
1 5 1
2 4 2
2 5 1
3 4 3
3 5 3
4 5 2
Output
7
*/


======================================== ./tuana/Quản lý hồ sơ hash function.c ========================================

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define HASH_SIZE 100
#define MAX_NAME 100
#define MAX_EMAIL 100

// BST Node for chaining
typedef struct BSTNode {
    char name[MAX_NAME];
    char email[MAX_EMAIL];
    struct BSTNode *left;
    struct BSTNode *right;
} BSTNode;

// Hash table
BSTNode *hashTable[HASH_SIZE];

// Hash function
int hashFunction(char *str) {
    int hash = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        hash = (hash * 256 + str[i]);
    }
    return hash % HASH_SIZE;
}

// Create new BST node
BSTNode *createNode(char *name, char *email) {
    BSTNode *node = (BSTNode *)malloc(sizeof(BSTNode));
    strcpy(node->name, name);
    strcpy(node->email, email);
    node->left = NULL;
    node->right = NULL;
    return node;
}

// Insert into BST
BSTNode *insertBST(BSTNode *root, char *name, char *email) {
    if (root == NULL) {
        return createNode(name, email);
    }

    int cmp = strcmp(name, root->name);
    if (cmp < 0) {
        root->left = insertBST(root->left, name, email);
    } else if (cmp > 0) {
        root->right = insertBST(root->right, name, email);
    } else {
        // Update email if name exists
        strcpy(root->email, email);
    }

    return root;
}

// Search in BST
BSTNode *searchBST(BSTNode *root, char *name) {
    if (root == NULL) {
        return NULL;
    }

    int cmp = strcmp(name, root->name);
    if (cmp == 0) {
        return root;
    } else if (cmp < 0) {
        return searchBST(root->left, name);
    } else {
        return searchBST(root->right, name);
    }
}

// Find minimum node in BST
BSTNode *findMin(BSTNode *root) {
    while (root->left != NULL) {
        root = root->left;
    }
    return root;
}

// Remove from BST
BSTNode *removeBST(BSTNode *root, char *name) {
    if (root == NULL) {
        return NULL;
    }

    int cmp = strcmp(name, root->name);
    if (cmp < 0) {
        root->left = removeBST(root->left, name);
    } else if (cmp > 0) {
        root->right = removeBST(root->right, name);
    } else {
        // Node found
        if (root->left == NULL) {
            BSTNode *temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            BSTNode *temp = root->left;
            free(root);
            return temp;
        }

        // Node with two children
        BSTNode *temp = findMin(root->right);
        strcpy(root->name, temp->name);
        strcpy(root->email, temp->email);
        root->right = removeBST(root->right, temp->name);
    }

    return root;
}

// Write BST to file (in-order traversal)
void writeBSTToFile(BSTNode *root, FILE *file) {
    if (root == NULL)
        return;

    writeBSTToFile(root->left, file);
    fprintf(file, "%s %s\n", root->name, root->email);
    writeBSTToFile(root->right, file);
}

// Insert student into hash table
void insertStudent(char *name, char *email) {
    int hash = hashFunction(name);
    hashTable[hash] = insertBST(hashTable[hash], name, email);
}

// Find student
void findStudent(char *name) {
    int hash = hashFunction(name);
    BSTNode *node = searchBST(hashTable[hash], name);

    if (node != NULL) {
        printf("%d %s\n", hash, node->email);
    } else {
        printf("Not found\n");
    }
}

// Remove student
void removeStudent(char *name) {
    int hash = hashFunction(name);
    hashTable[hash] = removeBST(hashTable[hash], name);
}

// Load from file or stdin
void loadFromFile() {
    int n;
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        char name[MAX_NAME], email[MAX_EMAIL];
        scanf("%s %s", name, email);
        insertStudent(name, email);
    }
}

// Store to file
void storeToFile(char *filename) {
    FILE *file = fopen(filename, "w");
    if (file == NULL) {
        printf("Error opening file\n");
        return;
    }

    for (int i = 0; i < HASH_SIZE; i++) {
        if (hashTable[i] != NULL) {
            writeBSTToFile(hashTable[i], file);
        }
    }

    fclose(file);
}

int main() {
    // Initialize hash table
    for (int i = 0; i < HASH_SIZE; i++) {
        hashTable[i] = NULL;
    }

    char command[20];

    while (1) {
        scanf("%s", command);

        if (strcmp(command, "Load") == 0) {
            loadFromFile();
        } else if (strcmp(command, "Find") == 0) {
            char name[MAX_NAME];
            scanf("%s", name);
            findStudent(name);
        } else if (strcmp(command, "Insert") == 0) {
            char name[MAX_NAME], email[MAX_EMAIL];
            scanf("%s %s", name, email);
            insertStudent(name, email);
        } else if (strcmp(command, "Remove") == 0) {
            char name[MAX_NAME];
            scanf("%s", name);
            removeStudent(name);
        } else if (strcmp(command, "Store") == 0) {
            char filename[100];
            scanf("%s", filename);
            storeToFile(filename);
        } else if (strcmp(command, "Quit") == 0) {
            printf("Bye\n");
            break;
        }
    }

    return 0;
}


======================================== ./tuana/Sequence of nodes visited by BFS.c ========================================

#include <stdio.h>
#include <stdlib.h>

#define MAX 100

// Queue structure
typedef struct {
    int items[MAX];
    int front;
    int rear;
} Queue;

// Initialize queue
void initQueue(Queue *q) {
    q->front = -1;
    q->rear = -1;
}

// Check if queue is empty
int isEmpty(Queue *q) {
    return q->front == -1;
}

// Enqueue operation
void enqueue(Queue *q, int value) {
    if (q->front == -1)
        q->front = 0;
    q->rear++;
    q->items[q->rear] = value;
}

// Dequeue operation
int dequeue(Queue *q) {
    int item = q->items[q->front];
    q->front++;
    if (q->front > q->rear) {
        q->front = q->rear = -1;
    }
    return item;
}

// Comparison function for sorting
int compare(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}

// BFS function for complete traversal
void bfs(int graph[MAX][MAX], int n) {
    int visited[MAX] = {0};
    Queue q;
    initQueue(&q);

    int first = 1;

    // Start from each unvisited node in lexicographic order
    for (int start = 1; start <= n; start++) {
        if (!visited[start]) {
            visited[start] = 1;
            enqueue(&q, start);

            while (!isEmpty(&q)) {
                int current = dequeue(&q);

                if (!first)
                    printf(" ");
                printf("%d", current);
                first = 0;

                // Collect neighbors
                int neighbors[MAX];
                int count = 0;

                for (int i = 1; i <= n; i++) {
                    if (graph[current][i] && !visited[i]) {
                        neighbors[count++] = i;
                    }
                }

                // Sort neighbors in lexicographic order
                qsort(neighbors, count, sizeof(int), compare);

                // Add sorted neighbors to queue
                for (int i = 0; i < count; i++) {
                    visited[neighbors[i]] = 1;
                    enqueue(&q, neighbors[i]);
                }
            }
        }
    }
    printf("\n");
}

int main() {
    int n, m;
    scanf("%d %d", &n, &m);

    int graph[MAX][MAX] = {0};

    // Read edges
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        graph[u][v] = 1;
        graph[v][u] = 1;
    }

    // Perform complete BFS traversal
    bfs(graph, n);

    return 0;
}
/*
Input
6 7
2 4
1 3
3 4
5 6
1 2
3 5
2 3

Output
1 2 3 4 5 6
*/


======================================== ./tuana/Sequence of nodes visited by DFS.c ========================================

#include <stdio.h>
#include <stdlib.h>

#define MAX 100

int visited[MAX] = {0};
int first = 1;

// Comparison function for sorting
int compare(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}

// DFS recursive function
void dfsVisit(int graph[MAX][MAX], int n, int node) {
    visited[node] = 1;

    if (!first)
        printf(" ");
    printf("%d", node);
    first = 0;

    // Collect neighbors
    int neighbors[MAX];
    int count = 0;

    for (int i = 1; i <= n; i++) {
        if (graph[node][i] && !visited[i]) {
            neighbors[count++] = i;
        }
    }

    // Sort neighbors in lexicographic order
    qsort(neighbors, count, sizeof(int), compare);

    // Visit sorted neighbors recursively
    for (int i = 0; i < count; i++) {
        if (!visited[neighbors[i]]) {
            dfsVisit(graph, n, neighbors[i]);
        }
    }
}

// DFS function for complete traversal
void dfs(int graph[MAX][MAX], int n) {
    // Start from each unvisited node in lexicographic order
    for (int start = 1; start <= n; start++) {
        if (!visited[start]) {
            dfsVisit(graph, n, start);
        }
    }
    printf("\n");
}

int main() {
    int n, m;
    scanf("%d %d", &n, &m);

    int graph[MAX][MAX] = {0};

    // Read edges
    for (int i = 0; i < m; i++) {
        int u, v;
        scanf("%d %d", &u, &v);
        graph[u][v] = 1;
        graph[v][u] = 1;
    }

    // Perform complete DFS traversal
    dfs(graph, n);

    return 0;
}
/*
Input
6 7
2 4
1 3
3 4
5 6
1 2
3 5
2 3

Output
1 2 3 4 5 6
*/


======================================== ./tuana/Shortest Path between 2 nodes on a directed graph with non-negative weights.c ========================================

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_NODES 100005

typedef struct {
    int v;
    long long weight;
} Edge;

typedef struct {
    Edge *edges;
    int count;
} AdjacencyList;

int main() {
    int n, m;
    scanf("%d %d", &n, &m);

    AdjacencyList *graph =
        (AdjacencyList *)malloc((n + 1) * sizeof(AdjacencyList));
    for (int i = 0; i <= n; i++) {
        graph[i].edges = (Edge *)malloc((m + 1) * sizeof(Edge));
        graph[i].count = 0;
    }

    for (int i = 0; i < m; i++) {
        int u, v;
        long long w;
        scanf("%d %d %lld", &u, &v, &w);

        graph[u].edges[graph[u].count].v = v;
        graph[u].edges[graph[u].count].weight = w;
        graph[u].count++;
    }

    int s, t;
    scanf("%d %d", &s, &t);

    // Dijkstra's algorithm using simple priority approach
    long long distance[MAX_NODES];
    int visited[MAX_NODES];

    for (int i = 1; i <= n; i++) {
        distance[i] = LLONG_MAX;
        visited[i] = 0;
    }

    distance[s] = 0;

    for (int i = 0; i < n; i++) {
        // Find unvisited node with minimum distance
        long long minDist = LLONG_MAX;
        int u = -1;

        for (int j = 1; j <= n; j++) {
            if (!visited[j] && distance[j] < minDist) {
                minDist = distance[j];
                u = j;
            }
        }

        if (u == -1 || distance[u] == LLONG_MAX)
            break;

        visited[u] = 1;

        for (int j = 0; j < graph[u].count; j++) {
            int v = graph[u].edges[j].v;
            long long w = graph[u].edges[j].weight;

            if (!visited[v] && distance[u] + w < distance[v]) {
                distance[v] = distance[u] + w;
            }
        }
    }

    if (distance[t] == LLONG_MAX) {
        printf("-1\n");
    } else {
        printf("%lld\n", distance[t]);
    }

    // Free memory
    for (int i = 0; i <= n; i++) {
        free(graph[i].edges);
    }
    free(graph);

    return 0;
}
/*
Input
5 7
2 5 87
1 2 97
4 5 78
3 1 72
1 4 19
2 3 63
5 1 18
1 5

Output
97
*/


======================================== ./tuana/TSP Lagre.c ========================================


